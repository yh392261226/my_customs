### Package Desc: è‡ªå®šä¹‰å‘½ä»¤

function search_aliases() {                                                         # Desc: function: search_aliases:æ˜¾ç¤ºæ‰€æœ‰å«æœ‰å­—ç¬¦ä¸²çš„è‡ªå®šä¹‰å‘½ä»¤åŠæ³¨é‡Š
    MYRUNTIME=$(cat $HOME/.myruntime)
    customcd $MYRUNTIME/customs/my_shell/library/functions/bzsh
    local Content
    if [ ""  != "$1" ]; then
        Content=$(find *.bzsh | xargs ag "$1" | awk -F':' '{print $1}' | sort | uniq )
    else
        Content=$(find *.bzsh | awk -F':' '{print $1}' | sort | uniq )
    fi
    echo "$Content" | fzf --no-sort \
    --tac \
    $FZF_CUSTOM_PARAMS \
    --preview-window right:70%:rounded:hidden:wrap \
    --preview 'bat --theme=gruvbox-dark --color=always --style=full {}' \
    --header="$(_buildFzfHeader '' 'search_aliases')"
    customcd -
}
alias sas="search_aliases"                                                          # Desc: alias: sas:search_aliaseså‘½ä»¤çš„åˆ«å,æ˜¾ç¤ºæ‰€æœ‰å«æœ‰å­—ç¬¦ä¸²çš„è‡ªå®šä¹‰å‘½ä»¤åŠæ³¨é‡Š

function fzf_all_aliases() {                                                        # Desc: function: fzf_all_aliases:æ˜¾ç¤ºæ‰€æœ‰è‡ªå®šä¹‰çš„åˆ«ååŠæ³¨é‡Š
    TMP_ALIASES_FILE=$(mktemp)
    alias | sed -e "s/^alias //g" > $TMP_ALIASES_FILE
    if [ -f $TMP_ALIASES_FILE ]; then
        eval $(cat $TMP_ALIASES_FILE | awk -F'=' '{print $1}' | sed -e "s/^[ ]*//g" | grep -v -E "^--(.*?)" | fzf $FZF_CUSTOM_PARAMS \
        --preview-window right:70%:rounded:hidden:wrap \
        --preview "$MYRUNTIME/customs/bin/_show_custom_alias {} $TMP_ALIASES_FILE"  \
        --header="$(_buildFzfHeader '' 'fzf_all_aliases')" \
        --bind "ctrl-r:execute(bat --theme=gruvbox-dark --color=always --style=full $TMP_ALIASES_FILE > /dev/tty)")
        rm -f $TMP_ALIASES_FILE
    fi
}
alias faa="fzf_all_aliases"                                                         # Desc: alias: faa: fzf_all_aliaseså‘½ä»¤çš„åˆ«å,æ˜¾ç¤ºæ‰€æœ‰è‡ªå®šä¹‰çš„åˆ«ååŠæ³¨é‡Š

function fzf_custom_aliases() {                                                     # Desc: function: fzf_custom_aliases:æ˜¾ç¤ºæ‰€æœ‰è‡ªå®šä¹‰å‘½ä»¤åŠæ³¨é‡Š
    local TMP_ALIASES_FILE=$(mktemp)

    find $MYRUNTIME/customs/my_shell/* -type f ! -path "$MYRUNTIME/customs/my_shell/nu/*" ! -path "$MYRUNTIME/customs/my_shell/fish/*" ! -path "$MYRUNTIME/customs/my_shell/library/functions/fish/*" | xargs grep -rE '^alias\ ' > $TMP_ALIASES_FILE
    if [ -f $TMP_ALIASES_FILE ]; then
        eval $(cat $TMP_ALIASES_FILE | awk '{print $2}' | sed "s/'//g" | sed 's/"//g' | awk -F'=' '{print $1}' | fzf --no-sort --tac $FZF_CUSTOM_PARAMS \
        --preview "$MYRUNTIME/customs/bin/_show_custom_alias {} ${TMP_ALIASES_FILE} \"customs\""  \
        --bind 'focus:transform-preview-label:echo -n "[ {} ]";' \
        --bind "ctrl-r:execute(bat --theme=gruvbox-dark --color=always --style=full $TMP_ALIASES_FILE > /dev/tty)" \
        --header="$(_buildFzfHeader '' 'fzf_custom_aliases')")
        rm -f $TMP_ALIASES_FILE
    fi
}
alias fca="fzf_custom_aliases"                                                      # Desc: alias: fca:fzf_custom_aliaseså‘½ä»¤çš„åˆ«å,æ˜¾ç¤ºæ‰€æœ‰è‡ªå®šä¹‰å‘½ä»¤åŠæ³¨é‡Š

function custom_aliases_from_a2z() {                                                # Desc: function: custom_aliases_from_a2z:æ˜¾ç¤ºä»a-zçš„è‡ªå®šä¹‰å‘½ä»¤
    # åˆ›å»ºä¸´æ—¶æ–‡ä»¶
    local TMP_A2Z_ALIASES_FILE=$(mktemp)
    # å°†æ‰€æœ‰a-zçš„åˆ«åå†…å®¹å†™å…¥ä¸´æ—¶æ–‡ä»¶
    if [ ! -f $TMP_A2Z_ALIASES_FILE ]; then
        echo "Tmpfile does not exists !"
        return 1
    fi

    hr "â¬³" > $TMP_A2Z_ALIASES_FILE
    echo -n "[ $(echo -e {a..z}) ]\n" >> $TMP_A2Z_ALIASES_FILE
    hr "â¬³" >> $TMP_A2Z_ALIASES_FILE
    echo "â­† Already exists command:" >> $TMP_A2Z_ALIASES_FILE
    hr "â¬³" >> $TMP_A2Z_ALIASES_FILE
    for word in {a..z}; do
        if [ "$(command -v $word)" != "" ]; then
            echo "alias_${word}_start" >> $TMP_A2Z_ALIASES_FILE
            type $word | grep -v "not found" >> $TMP_A2Z_ALIASES_FILE
            if [ "$nowshell" != "bash" ]; then
                hr "â†¼" >> $TMP_A2Z_ALIASES_FILE
                which $word | grep -v "not found" >> $TMP_A2Z_ALIASES_FILE
                hr "â†¼" >> $TMP_A2Z_ALIASES_FILE
            fi
            echo "alias_${word}_end" >> $TMP_A2Z_ALIASES_FILE
        fi
    done

    if [ "all" = "$1" ] && [ "" != "$1" ]; then
        bat $TMP_A2Z_ALIASES_FILE
    else
        # åˆ©ç”¨fzf
        seq 1 26 |  awk '{printf "%c\n", NR+96}' | fzf $FZF_CUSTOM_PARAMS \
        --header="$(_buildFzfHeader '' 'custom_aliases_from_a2z')" \
        --preview-window 'right,70%,rounded,+{2}+3/3,~3' \
        --preview "$MYRUNTIME/customs/bin/_show_custom_alias {} ${TMP_A2Z_ALIASES_FILE} \"a2z\""
    fi
}
alias a2z="custom_aliases_from_a2z"                                                 # Desc: alias: a2z:custom_aliases_from_a2zå‘½ä»¤çš„åˆ«å,æ˜¾ç¤ºä»a-zçš„è‡ªå®šä¹‰å‘½ä»¤

function fzf_all_custom_functions() {                                               # Desc: function: fzf_all_custom_functions:æ˜¾ç¤ºæ‰€æœ‰å‡½æ•°(ä»…zshä¸‹æœ‰æ•ˆ)
    local TMP_ALL_FUNCTIONS_FILE=$(mktemp)

    if [[ "zsh" = "$nowshell" ]]; then
        functions > $TMP_ALL_FUNCTIONS_FILE 
        selected=$(cat $TMP_ALL_FUNCTIONS_FILE | grep -E '(.*?)[^(]*.*{' | grep -v '$MYRUNTIME' | grep '() {' | grep -v '$MYRUNTIME'  | grep -E '^[+_@.-:]+[a-zA-Z0-9_]*|[a-zA-Z0-9_]*'| sed 's/^[[:blank:]]\{1,\}//' | grep -v '^() {' |sed 's/ () {//' | grep -v ' ' | fzf $FZF_CUSTOM_PARAMS +m \
        --preview-window right:70%:rounded:hidden:wrap \
        --preview "$MYRUNTIME/customs/bin/_show_awesome_function {} $TMP_ALL_FUNCTIONS_FILE 'functions' $nowshell" \
        --header="$(_buildFzfHeader '' 'fzf_all_custom_functions')" \
        --bind="f12:execute-silent($MYRUNTIME/customs/bin/_show_awesome_function {} $TMP_ALL_FUNCTIONS_FILE 'functions' $nowshell| pbcopy)+abort")
    fi
    if [[ "bash" = "$nowshell" ]]; then
        declare -f > $TMP_ALL_FUNCTIONS_FILE
        selected=$(cat $TMP_ALL_FUNCTIONS_FILE | grep -E '(.*?)[^ (]*.*' |grep -v '$MYRUNTIME' |grep ' ()' |grep -v '$MYRUNTIME'  | grep -E '^[+_@.-:]+[a-zA-Z0-9_]*|[a-zA-Z0-9_]* ()'|grep -v '"' | grep -v "'" | grep -v ' function ' | sed 's/^[[:blank:]]\{1,\}//' | grep -v '^()$' |sed 's/ ()//' | fzf $FZF_CUSTOM_PARAMS +m \
        --preview-window right:70%:rounded:hidden:wrap \
        --preview "$MYRUNTIME/customs/bin/_show_awesome_function {} $TMP_ALL_FUNCTIONS_FILE 'functions' $nowshell" \
        --header="$(_buildFzfHeader '' 'fzf_all_custom_functions')" \
        --bind="f12:execute-silent($MYRUNTIME/customs/bin/_show_awesome_function {} $TMP_ALL_FUNCTIONS_FILE 'functions' $nowshell| pbcopy)+abort")
    fi
    if [ -n "$selected" ]; then
        $MYRUNTIME/customs/bin/_show_awesome_function $selected $TMP_ALL_FUNCTIONS_FILE 'functions' $nowshell
    fi
    rm -f $TMP_ALL_FUNCTIONS_FILE
}
alias faf='fzf_all_custom_functions'                                                # Desc: alias: faf: fzf_all_custom_functionså‘½ä»¤çš„åˆ«å,æ˜¾ç¤ºæ‰€æœ‰å‡½æ•°(ä»…zshä¸‹æœ‰æ•ˆ)

function fzf_customs_functions() {                                                  # Desc: function: fzf_customs_functions:æ˜¾ç¤ºæ‰€æœ‰è‡ªå®šä¹‰å‘½ä»¤åŠæ³¨é‡Š
    TMP_FUNCTIONS_FILE=$(mktemp)
    find $MYRUNTIME/customs/my_shell/library/functions/ -type f -name "*bzsh" |xargs grep -E "(function )(.*?)[^(]*.*#.*Desc" |grep -v '$MYRUNTIME' > $TMP_FUNCTIONS_FILE
    if [ -f $TMP_FUNCTIONS_FILE ]; then
        eval $(cat $TMP_FUNCTIONS_FILE | awk '{$1=""; print $0 }' | \
        sed 's/^[[:blank:]]\{1,\}//' | \
        sed -e "s/() {//" | awk -F'#' '{print $1}' | \
        grep -E "(.*?)[^(]*" | \
        sed -e 's/ $//g' | \
        fzf $FZF_CUSTOM_PARAMS \
        --preview-window right:70%:rounded:hidden:wrap \
        --preview "$MYRUNTIME/customs/bin/_show_awesome_function {} $TMP_FUNCTIONS_FILE" \
        --header="$(_buildFzfHeader '' 'fzf_customs_functions')" \
        --bind "ctrl-r:execute(bat $TMP_FUNCTIONS_FILE > /dev/tty)")
        rm -f $TMP_FUNCTIONS_FILE
    fi
}
alias fcf="fzf_customs_functions"                                                   # Desc: alias: fcf:fzf_customs_functionså‘½ä»¤çš„åˆ«å,æ˜¾ç¤ºæ‰€æœ‰è‡ªå®šä¹‰å‘½ä»¤åŠæ³¨é‡Š

function fzf_customs_fzf_awesome_functions_list() {                                 # Desc: function: fzf_customs_fzf_awesome_functions_list: åˆ©ç”¨fzfåˆ—å‡ºæ‰€æœ‰è‡ªå®šä¹‰fzfç›¸å…³å‘½ä»¤
    if [ ! -f $HOME/.myruntime ]; then
        echo "Awesome Fzf Functions Location Not Found !"
    else
        AWESOME_FZF_FUNCTIONS_LOCATION=$(cat $HOME/.myruntime)/customs/my_shell/
        TMP_FZF_FUNCTIONS_FILE=$(mktemp)
        find $AWESOME_FZF_FUNCTIONS_LOCATION -type f -name "*bzsh" |xargs grep -E "(function fzf_)(.*?)[^(]*" > $TMP_FZF_FUNCTIONS_FILE
        if [ ! -f $TMP_FZF_FUNCTIONS_FILE ]; then
            echo "Awesome Fzf Functions Collection File Does Not Exists !"
        else
            eval $(cat $TMP_FZF_FUNCTIONS_FILE | \
            awk '{$1=""; print $0 }' | \
            sed 's/^[[:blank:]]\{1,\}//' | sed -e "s/() {//" | \
            awk -F'#' '{print $1}' | \
            grep -E "(^fzf_)(.*?)[^(]*" | \
            sed -e 's/ $//g' | \
            fzf $FZF_CUSTOM_PARAMS \
            --preview "$MYRUNTIME/customs/bin/_show_awesome_function {} $TMP_FZF_FUNCTIONS_FILE" \
            --preview-window right:70%:rounded:hidden:wrap \
            --bind "ctrl-r:execute(bat $TMP_FZF_FUNCTIONS_FILE > /dev/tty)" \
            --header="$(_buildFzfHeader '' 'fzf_customs_fzf_awesome_functions_list')")
            rm -f $TMP_FZF_FUNCTIONS_FILE
        fi
    fi
}
alias fff="fzf_customs_fzf_awesome_functions_list"                                  # Desc: alias: fff: fzf_customs_fzf_awesome_functions_listå‘½ä»¤çš„åˆ«å,åˆ©ç”¨fzfåˆ—å‡ºæ‰€æœ‰è‡ªå®šä¹‰fzfç›¸å…³å‘½ä»¤
alias 3f="fzf_customs_fzf_awesome_functions_list"                                   # Desc: alias: 3f: fzf_customs_fzf_awesome_functions_listå‘½ä»¤çš„åˆ«å,åˆ©ç”¨fzfåˆ—å‡ºæ‰€æœ‰è‡ªå®šä¹‰fzfç›¸å…³å‘½ä»¤

function update_iterm2_shell_integration() {                                        # Desc: function: update_iterm2_shell_integration:æ›´æ–°iterm2çš„æ‰©å±•shell
	curl -L https://iterm2.com/shell_integration/install_shell_integration_and_utilities.sh | bash
}
alias uii="update_iterm2_shell_integration"                                         # Desc: alias: uii:update_iterm2_shell_integrationå‘½ä»¤çš„åˆ«å,æ›´æ–°iterm2çš„æ‰©å±•shell

function my_message() {                                                             # Desc: function: my_message:æ˜¾ç¤ºæˆ‘çš„è‡ªå®šä¹‰SHELLå¤´ä¿¡æ¯
    clear
    _COLUMNS=$(tput cols)
    source $MYRUNTIME/tools/m_title
    y=$(( ( $_COLUMNS - ${#_TITLE} )  / 2 ))
    spaces=$(printf "%-${y}s" " ")
    echo " "
    echo -e "${spaces}\033[41;37;5m ${_TITLE} \033[0m"
    echo " "


    _COLUMNS=$(tput cols)
    source $MYRUNTIME/tools/m_message
    y=$(( ( $_COLUMNS - ${#_MESSAGE} )  / 2 ))
    spaces=$(printf "%-${y}s" " ")
    echo -e "${spaces}${_MESSAGE}"
    echo " "
    for ((i=1; i<=$(tput cols); i ++))  ; do echo -n '*';done

    echo " "
}
alias mm="my_message"                                                               # Desc: alias: mm:my_messageå‘½ä»¤çš„åˆ«å,æ˜¾ç¤ºæˆ‘çš„è‡ªå®šä¹‰SHELLå¤´ä¿¡æ¯

function show_bad_links() {                                                         # Desc: function: show_bad_links:åˆ—å‡ºæ‰€æœ‰å¤±æ•ˆè½¯è¿æ¥,é»˜è®¤è¯»å–å®¶ç›®å½•,å¯ä»¥æŒ‡å®šç›®å½•badlink /data
    local readpath="${1:-$HOME}"
    echo "File List broken links:"
    for file in $(ls -a $readpath); do
    realpath=$(/usr/bin/readlink $readpath/$file)
    if [ ! -f $realpath ] && [ ! -d $realpath ]; then
        echo $readpath/$file
    fi
    done
}
alias badlinks="show_bad_links"                                                     # Desc: alias: badlink:show_bad_linkså‘½ä»¤çš„åˆ«å,åˆ—å‡ºæ‰€æœ‰å¤±æ•ˆè½¯è¿æ¥,é»˜è®¤è¯»å–å®¶ç›®å½•,å¯ä»¥æŒ‡å®šç›®å½•badlink /data
alias sbl="show_bad_links"                                                          # Desc: alias: sbl:show_bad_linkså‘½ä»¤çš„åˆ«å,åˆ—å‡ºæ‰€æœ‰å¤±æ•ˆè½¯è¿æ¥,é»˜è®¤è¯»å–å®¶ç›®å½•,å¯ä»¥æŒ‡å®šç›®å½•badlink /data

function build_by_extension() {                                                     # Desc: function: build_by_extension:ç”Ÿæˆã€å‚æ•°ä¸ºåç¼€åçš„ã€‘çš„æ•°æ®æ–‡ä»¶
    [ $# -eq 0 ] && return
    cmd="find `pwd`"
    for ext in $@; do
        cmd=" $cmd -name '*.$ext' -o"
    done
    echo ${cmd: 0: ${#cmd} - 3}
    eval "${cmd: 0: ${#cmd} - 3}" > cscope.files &&
        cscope -b -q && rm cscope.files
}
alias bbe="build_by_extension"                                                      # Desc: alias: bbe: build_by_extensionå‘½ä»¤çš„åˆ«å,ç”Ÿæˆã€å‚æ•°ä¸ºåç¼€åçš„ã€‘çš„æ•°æ®æ–‡ä»¶

function clear_camera_cache() {                                                     # Desc: function: clear_camera_cache:æ¸…ç†æ‘„åƒå¤´ç¼“å­˜
    sudo killall VDCAssistant
}
alias 3c="clear_camera_cache"                                                       # Desc: alias: 3c: clear_camera_cacheå‘½ä»¤çš„åˆ«å,æ¸…ç†æ‘„åƒå¤´ç¼“å­˜

function sign_tnt_code_name() {                                                     # Desc: function: sign_tnt_code_name:TNTç ´è§£å¤±æ•ˆ æ›´æ”¹ç­¾å
    if [ $# -ne 1 ]; then
        echo "Type $0 App path to replace the app sign"
        return 1
    fi
    if [ -d "$1" ]; then
        /usr/bin/codesign --force --deep --sign - "$1"
    else
        echo "The app path does not exists !!!"
        return 1
    fi
}
alias cs="sign_tnt_code_name"                                                       # Desc: alias: cs:sign_tnt_code_nameå‘½ä»¤çš„åˆ«å,TNTç ´è§£å¤±æ•ˆ,æ›´æ”¹ç­¾å
alias stnt="sign_tnt_code_name"                                                     # Desc: alias: stnt:sign_tnt_code_nameå‘½ä»¤çš„åˆ«å,TNTç ´è§£å¤±æ•ˆ,æ›´æ”¹ç­¾å

function speaking_by_osx_voice() {                                                  # Desc: function: speaking_by_osx_voice:åˆ©ç”¨osxç³»ç»Ÿå‘éŸ³è¯´è¯
    words="$@"
    hasgum=$(ifHasCommand gum)
    if [ "" = "$words" ]; then
        [[ 1 = $hasgum ]] && (gum input --placeholder "Type something...") || (echo "è¯·è¾“å…¥è¦è¯´çš„è¯ \nä¾‹å¦‚ï¼š$0 haha " && return 1)
    fi
    #osascript -e 'say "'$words'" using "Cellos"'
    osascript -e 'say "'$words'" using "Ting-Ting"'
}
alias sbov="speaking_by_osx_voice"                                                  # Desc: alias: sbov: speaking_by_osx_voiceå‘½ä»¤çš„åˆ«å,åˆ©ç”¨osxç³»ç»Ÿå‘éŸ³è¯´è¯

function my_weather() {                                                             # Desc: function: my_weather:è·å–å“ˆå°”æ»¨å¤©æ°”
    if [ -f /opt/homebrew/opt/curl/bin/curl ]; then
        /opt/homebrew/opt/curl/bin/curl https://wttr.in/harbin\?lang\=zh
    else
        curl https://wttr.in/harbin\?lang\=zh
    fi
}
alias myweather="my_weather"                                                        # Desc: alias: myweather:my_weatherå‘½ä»¤çš„åˆ«å,è·å–å“ˆå°”æ»¨å¤©æ°”

function history_sort_by_used() {                                                   # Desc: function: history_sort_by_used:æŒ‰æ‰§è¡Œæ¬¡æ•°å€’åºæ˜¾ç¤ºå†å²å‘½ä»¤
    local last_command_type=`history | tail -n 1 | awk '{print($0~/^[-]?([0-9])+[.]?([0-9])+$/)?"number":"string"}'`
    if [ "$last_command_type" = "number" ]; then
        history | awk '{$1="";print}' | sort -rn | uniq -c | sort -rn | less
    else
        history | sort -rn | uniq -c | sort -rn | less
    fi
}
alias hsu="history_sort_by_used"                                                    # Desc: alias: hsu: history_sort_by_usedå‘½ä»¤çš„åˆ«å,æŒ‰æ‰§è¡Œæ¬¡æ•°å€’åºæ˜¾ç¤ºå†å²å‘½ä»¤

function fzf_history_repeat() {                                                     # Desc: function: fzf_history_repeat:åˆ—å‡ºå†å²æ“ä½œå‘½ä»¤,é€‰æ‹©åæ‰§è¡Œ
    eval $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac $FZF_CUSTOM_PARAMS \
    --preview ' echo {} | awk "{\$1=\"\";print}"' \
    --bind 'focus:transform-preview-label:echo -n "[ {1} ]";' \
    --bind 'f12:execute-silent(echo {} | awk "{\$1=\"\";print}" | pbcopy)+abort' \
    --border-label='â•¢ ğŸ‘£ History â•Ÿ' \
    --header-label='â•¢ ğŸ‘£ History â•Ÿ' \
    --header="$(_buildFzfHeader '' 'fzf_aliases')" \
     | sed 's/ *[0-9]* *//')
}
alias fhr="fzf_history_repeat"                                                      # Desc: alias: fhr:fzf_history_repeatå‘½ä»¤çš„åˆ«å,åˆ—å‡ºå†å²æ“ä½œå‘½ä»¤,é€‰æ‹©åæ‰§è¡Œ

function help_by_tldr() {                                                           # Desc: function: help_by_tldr:helpå¸®åŠ©,tldrå‘½ä»¤åˆ«å
    tldr $@
}
alias help="help_by_tldr"                                                           # Desc: alias: help:help_by_tldrå‘½ä»¤çš„åˆ«å,helpå¸®åŠ©,tldrå‘½ä»¤åˆ«å

function ps_or_procs_search() {                                                     # Desc: function: ps_or_procs_search:ps -efæˆ–procs |grep è¿›ç¨‹
    [[ "" = "$@" ]] && return 1
    if command -v procs &> /dev/null
    then
        procs | grep "$@" | grep -v grep 
    else
        ps -ef|grep "$@" | grep -v grep #|fzf
    fi
}
alias p='ps_or_procs_search'                                                        # Desc: alias: p:ps_or_procs_searchå‘½ä»¤çš„åˆ«å,ps -efæˆ–procs |grep è¿›ç¨‹

function btop() {                                                                   # Desc: function: btop:bashtopå‘½ä»¤çš„åˆ«å 
    [[ -f /usr/local/bin/bashtop ]] && /usr/local/bin/bashtop "$@" || echo "bashtop does not exists !"
}
alias bt="btop"                                                                     # Desc: alias: bt: btopå‘½ä»¤çš„åˆ«å,bashtopå‘½ä»¤çš„åˆ«å 

function fzf_history() {                                                            # Desc: function: fzf_history:ä¾èµ–fzfè¯»å–historyç»“æœ
    history | fzf $FZF_CUSTOM_PARAMS \
    --preview ' echo {} | awk "{\$1=\"\";print}"' \
    --bind 'focus:transform-preview-label:echo -n "[ {1} ]";' \
    --header="$(_buildFzfHeader '' 'fzf_history')" \
    --border-label='â•¢ ğŸ‘£ History â•Ÿ' \
    --header-label='â•¢ ğŸ‘£ History â•Ÿ' \
    --bind 'f12:execute-silent(echo {} | awk "{\$1=\"\";print}" | pbcopy)+abort'
}
alias fh="fzf_history"                                                              # Desc: alias: fh:fzf_historyå‘½ä»¤çš„åˆ«å,ä¾èµ–fzfè¯»å–historyç»“æœ

function file_tree() {                                                              # Desc: function: file_tree:treeå‘½ä»¤
	mpath='./'
	[[ "" != "$1" ]] && mpath=$1
	ls -R $mpath | grep ":$" | sed -e 's/:$//' -e 's/[^-][^\/]*\//--/g' -e 's/^/ /' -e 's/-/|/'
}
alias ftree="file_tree"                                                             # Desc: alias: ftree:file_treeå‘½ä»¤çš„åˆ«å,treeå‘½ä»¤

function fzf_history_print() {                                                      # Desc: function: fzf_history_print:åˆ—å‡ºå†å²æ“ä½œå‘½ä»¤,é€‰æ‹©åæ‰“å°
    print -z $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac $FZF_CUSTOM_PARAMS \
    --preview ' echo {} | awk "{\$1=\"\";print}"' \
    --bind 'focus:transform-preview-label:echo -n "[ {1} ]";' \
    --bind 'f12:execute-silent(echo {} | awk "{\$1=\"\";print}" | pbcopy)+abort' \
    --header="$(_buildFzfHeader '' 'fzf_history_print')" \
    --border-label='â•¢ ğŸ‘£ History â•Ÿ' \
    --header-label='â•¢ ğŸ‘£ History â•Ÿ' \
    | sed -E 's/ *[0-9]*\*? *//' | sed -E 's/\\/\\\\/g')
}
alias fhp='fzf_history_print'                                                       # Desc: alias: fhp:fzf_history_printå‘½ä»¤çš„åˆ«å,åˆ—å‡ºå†å²æ“ä½œå‘½ä»¤,é€‰æ‹©åæ‰“å°

function fzf_theme_selector() {                                                     # Desc: function: fzf_theme_selector:fzfä¸»é¢˜é€‰æ‹©å™¨
    #MYRUNTIME=$(cat $HOME/.myruntime)
    themes_path=$MYRUNTIME/customs/tools/fzf_themes/
    choose_theme=$(ls $themes_path | fzf $FZF_CUSTOM_PARAMS --preview-window right:70%:rounded:hidden:wrap --preview " bat $themes_path/{} " --header="$(_buildFzfHeader '' 'fzf_aliases')")
    [[ ! "$choose_theme" ]] && echo "Action abort!" && return
    if [[ -f ${themes_path}/$choose_theme ]]; then
        source ${themes_path}/$choose_theme
    fi
}
alias fts='fzf_theme_selector'                                                      # Desc: alias: fts:fzf_theme_selectorå‘½ä»¤çš„åˆ«å,fzfä¸»é¢˜é€‰æ‹©å™¨

function command_sl_selector() {                                                    # Desc: function: command_sl_selector:è¾“å…¥å‘½ä»¤slå¹¶æ‰§è¡Œæ—¶ï¼ŒäºŒæ¬¡éªŒè¯é€‰æ‹©
    echo "æ‰§è¡Œå‘½ä»¤è¡Œå°ç«è½¦ï¼š1, lså‘½ä»¤ï¼š2"
    hasgum=$(ifHasCommand gum)
    [[ "$hasgum" = "1" ]]  && choose=$(gum choose "1" "2") || read choose
    case "$choose" in
    "1")
        [[ -f /opt/homebrew/bin/sl ]] && /opt/homebrew/bin/sl
        [[ -f /usr/local/bin/sl ]] && /usr/local/bin/sl
    ;;
    "2")
        [[ -f /usr/local/bin/lsd ]] && /usr/local/bin/lsd -la
        [[ -f /opt/homebrew/bin/lsd ]] && /opt/homebrew/bin/lsd -la
    ;;
    "*")
        echo "æ— æ•ˆé€‰æ‹©ï¼Œè‡ªåŠ¨é€€å‡º..."
    ;;
    esac
}
alias sl='command_sl_selector'                                                      # Desc: alias: sl:command_sl_selectorå‘½ä»¤çš„åˆ«å,è¾“å…¥å‘½ä»¤slå¹¶æ‰§è¡Œæ—¶ï¼ŒäºŒæ¬¡éªŒè¯é€‰æ‹©

function tre2() {                                                                   # Desc: function: tre2:treå‘½ä»¤åˆ—å‡ºæ‰€æœ‰æ–‡ä»¶ï¼Œå¹¶ç”Ÿæˆaliaså‘½ä»¤æ–‡ä»¶,æŒ‰ç”Ÿæˆçš„aliasè¿›è¡Œæ‰§è¡Œ
    command tre "$@" --editor nvim && source "/tmp/tre_aliases_$USER" 2>/dev/null;
    if [ -f /tmp/tre_aliases_$USER ]; then
#        source "/tmp/tre_aliases_$USER" 2>/dev/null;
        local choose=$(cat /tmp/tre_aliases_$USER | sed 's/"//g' | sed "s/'//g" | sed 's/"//g' | sed "s/'//g" | sed 's/^alias //g' | sed 's/=eval nvim \\/=/g' | sed 's/\\//g' | fzf $FZF_CUSTOM_PARAMS \
        --delimiter '=' \
        --preview 'echo "AliasName:{1}\nAliasTo:{2}"' \
        --bind 'f12:execute-silent(echo -n {1} | pbcopy)+abort')
        if [ "" != "$choose" ]; then
            eval $(echo $choose | awk -F'=' '{print $1}')
        fi
    fi
}
alias t2="tre2"                                                                     # Desc: alias: t2:tre2å‘½ä»¤çš„åˆ«åï¼Œtreå‘½ä»¤åˆ—å‡ºæ‰€æœ‰æ–‡ä»¶ï¼Œå¹¶ç”Ÿæˆaliaså‘½ä»¤æ–‡ä»¶,æŒ‰ç”Ÿæˆçš„aliasè¿›è¡Œæ‰§è¡Œ

function fzf_man() {                                                                # Desc: function: fzf_man:fzfç‰ˆæœ¬çš„manå‘½ä»¤
  manpage="echo {} | sed 's/\([[:alnum:][:punct:]]*\) (\([[:alnum:]]*\)).*/\2 \1/'"
  batman="${manpage} | xargs -r man | col -bx | bat --language=man --plain --color always --theme=\"Monokai Extended\""
   man -k . | sort \
   | awk -v cyan=$(tput setaf 6) -v blue=$(tput setaf 4) -v res=$(tput sgr0) -v bld=$(tput bold) '{ $1=cyan bld $1; $2=res blue $2; } 1' \
   | fzf  \
      -q "$1" \
      --ansi \
      --tiebreak=begin \
      --prompt='ïš Man > '  \
      --preview-window '50%,rounded,<50(up,85%,border-bottom)' \
      --preview "${batman}" \
      --bind "enter:execute(${manpage} | xargs -r man)" \
      --bind "Ã§:+change-preview(cht {1})+change-prompt(ï¯½ Cheat > )" \
      --bind "Âµ:+change-preview(${batman})+change-prompt(ïš Man > )" \
      --bind "Â®:+change-preview(tldr --color=always {1})+change-prompt(ï³ TLDR > )" \
      --header="$(_buildFzfHeader '' 'fzf_man')"
  zle reset-prompt
}
alias fman="fzf_man"                                                                # Desc: alias: fman:fzf_manå‘½ä»¤çš„åˆ«å,fzfç‰ˆæœ¬çš„manå‘½ä»¤
# `Ctrl-H` keybinding to launch the widget (this widget works only on zsh, don't know how to do it on bash and fish (additionaly pressing`ctrl-backspace` will trigger the widget to be executed too because both share the same keycode)
if [ "zsh" = "$nowshell" ]; then
    bindkey '^h' fzf_man
    zle -N fzf_man
else
    export -f fzf_man
    bind '"\C-H":"fzf_man;\n"'   #//Ctrl H æ‰§è¡Œfzf_man_widgetå‡½æ•°
fi

function fzf_fuzzy_cheat() {                                                        # Desc: function:fzf_fuzzy_cheat:åˆ©ç”¨ fzf çš„Cheat Sheet æœç´¢å™¨
    curl -s https://cheat.sh/:list | fzf --height 40% --reverse --preview 'curl -s https://cheat.sh/{} | bat --color=always -l man' --preview-window right:60%
}
alias ffc="fzf_fuzzy_cheat"                                                         # Desc: alias: ffc: fzf_fuzzy_cheatå‘½ä»¤çš„åˆ«å,åˆ©ç”¨ fzf çš„Cheat Sheet æœç´¢å™¨

function mark_by_cheatsh() {                                                        # Desc: function: mark_by_cheatsh:ä¾æ‰˜äºcheat.shçš„å¤‡å¿˜å½•
    if [ $# -lt 1 ]; then
        echo "Usage:$0 language function"
        echo ""
        echo "---------------------------------------"
        echo ""
        curl cht.sh
        return 0
    fi
    url="cheat.sh/"
    if [ "$1" != "" ]; then
        url="cheat.sh/$1/"
    fi
    if [ "$2" != "" ]; then
        url="cheat.sh/$1/$2"
    fi
    if [ "$3" != "" ]; then
        url="cheat.sh/$1/$2+$3"
    fi
    curl $url
}
alias mbc="mark_by_cheatsh"                                                         # Desc: alias: mbc:mark_by_cheatshå‘½ä»¤çš„åˆ«å,ä¾æ‰˜äºcheat.shçš„å¤‡å¿˜å½•

function fzf_env_vars() {                                                           # Desc: function: fzf_env_vars:åˆ©ç”¨fzfé€‰ç”¨envå˜é‡çš„å€¼
  env | fzf $FZF_CUSTOM_PARAMS \
    --bind 'ctrl-k:execute-silent(echo {1} | pbcopy)+abort' \
    --bind 'ctrl-v:execute-silent(echo {2} | pbcopy)+abort' \
    --bind 'focus:transform-preview-label:echo [ {1} ]' \
    --delimiter='=' \
    --preview='echo {2}' \
    --header="$(_buildFzfHeader '' 'fzf_env_vars')"
}
alias fev="fzf_env_vars"                                                            # Desc: alias: fev: fzf_env_varså‘½ä»¤çš„åˆ«å,åˆ©ç”¨fzfé€‰ç”¨envå˜é‡çš„å€¼

function fold() {                                                                   # Desc: function: fold: Default `fold` to screen width and break at spaces
    if [ $# -eq 0 ]; then
        /usr/bin/fold -w $COLUMNS -s
    else
        /usr/bin/fold $*
    fi
}

function fzf_spell() {                                                              # Desc: function: fzf_spell: Use `fzf` against system dictionary
  cat /usr/share/dict/words | fzf $FZF_CUSTOM_PARAMS \
    --preview-window up:70%:rounded:hidden:wrap \
    --preview 'wn {} -over | fold' \
    --header="$(_buildFzfHeader '' 'fzf_spell')"
}
alias fspell='fzf_spell'                                                            # Desc: alias: fspell: fzf_spellå‘½ä»¤çš„åˆ«å,Use `fzf` against system dictionary

function dic() {                                                                    # Desc: function: dic: Lookup definition of word using `wn $1 -over`.If $1 is not provided, we'll use the `spell` command to pick a word. Requires:brew install wordnet, brew install fzf
    if [ $# -eq 0 ]; then
        wn `fzf_spell` -over | fold
    else
        wn $1 -over | fold
    fi
}

function fzf_fg() {                                                                 # Desc: function: fzf_fg: åˆ©ç”¨fzfæ˜¾ç¤ºæ‰€æœ‰çš„åå°æ‰§è¡Œç¨‹åº
  job="$(jobs | fzf -0 -1 $FZF_CUSTOM_PARAMS \
    --preview 'echo {} | awk "{\$1=\"\";\$2=\"\";\$3=\"\";print}"' \
    --bind 'focus:transform-preview-label:echo -n "[ {1} ]";' \
    --bind 'f12:execute-silent(echo {} | awk "{\$1=\"\";\$2=\"\";\$3=\"\";print}" | pbcopy)+abort' \
    --header="$(_buildFzfHeader '' 'fzf_fg')" \
  | sed -E 's/\[(.+)\].*/\1/')" && echo '' && fg %$job
}
alias ffg="fzf_fg"                                                                  # Desc: alias: ffg: fzf_fgå‘½ä»¤çš„åˆ«å,åˆ©ç”¨fzfæ˜¾ç¤ºæ‰€æœ‰çš„åå°æ‰§è¡Œç¨‹åº

function su() {                                                                     # Desc: function: su:suå‘½ä»¤å,themeè‡ªåŠ¨åˆ‡æ¢ä¸»é¢˜
	(
		INHIBIT_THEME_HIST=1 $MYRUNTIME/customs/bin/theme red-alert
		trap '$MYRUNTIME/customs/bin/theme "$($MYRUNTIME/customs/bin/theme -l|tail -n1)"' INT
		env su "$@"
		$MYRUNTIME/customs/bin/theme "$($MYRUNTIME/customs/bin/theme -l|tail -n1)"
	)
}

function sudo() {                                                                   # Desc: function: sudo:sudoå‘½ä»¤å,themeè‡ªåŠ¨åˆ‡æ¢ä¸»é¢˜
	(
		pid=$(exec sh -c 'echo "$PPID"')
		# If the command takes less than .2s, don't change the theme.
		# We could also just match on 'su' and ignore everything else,
		# but this also accomodates other long running commands
		# like 'sudo sleep 5s'. Modify to taste.
		(
            sleep .2s
            ps -p "$pid" > /dev/null && INHIBIT_THEME_HIST=1 $MYRUNTIME/customs/bin/theme gruvbox-original-light-medium
		) &
		trap '$MYRUNTIME/customs/bin/theme "$($MYRUNTIME/customs/bin/theme -l|tail -n1)"' INT
		env sudo "$@"
		$MYRUNTIME/customs/bin/theme "$($MYRUNTIME/customs/bin/theme -l|tail -n1)"
	)
}

function ssh() {                                                                    # Desc: function: ssh:sshå‘½ä»¤å,themeè‡ªåŠ¨åˆ‡æ¢ä¸»é¢˜
	# A tiny ssh wrapper which extracts a theme from $HOME/.ssh_themes
	# and applies it for the duration of the current ssh command.
	# Each line in $HOME/.ssh_themes has the format:
	#     <hostname>: <theme>.
	# Restoration relies on the fact that you are using theme.sh to manage
	# the current theme.  (that is, you set the theme in your bashrc.)
	# This can probably be made more robust. It is just a small demo
	# of what is possible.
	touch $HOME/.ssh_themes
	host="$(echo "$@"|awk '{gsub(".*@","",$NF);print $NF}')"
	theme="$(awk -vhost="$host" -F': *' 'index($0, host":") == 1 {print $2}' < $HOME/.ssh_themes)"
	if [ -z "$theme" ]; then
		env ssh "$@"
		return
	fi
	INHIBIT_THEME_HIST=1 $MYRUNTIME/customs/bin/theme "$theme"
	trap '$MYRUNTIME/customs/bin/theme "$($MYRUNTIME/customs/bin/theme -l|tail -n1)"' INT
	env ssh "$@"
	$MYRUNTIME/customs/bin/theme "$($MYRUNTIME/customs/bin/theme -l|tail -n1)"
}

function last_theme() {                                                             # Desc: function: last_theme: è·å–themeå‘½ä»¤æœ€åä¸€æ¬¡çš„è®¾ç½®
	echo $($MYRUNTIME/customs/bin/theme -l|tail -n2|head -n1)
}
alias ltheme="last_theme"                                                           # Desc: alias: ltheme: last_themeå‘½ä»¤çš„åˆ«å,è·å–themeå‘½ä»¤æœ€åä¸€æ¬¡çš„è®¾ç½®

function fzf_open_app() {                                                           # Desc: function: fzf_open_app: åˆ©ç”¨fzfé€šè¿‡ç»ˆç«¯æ‰“å¼€App
    ls /Applications/ | fzf --ansi $FZF_CUSTOM_PARAMS \
--preview-window right:70%:rounded:hidden:wrap \
--preview 'tree /Applications/{}' \
--bind 'enter:become(open /Applications/{})' \
--header="$(_buildFzfHeader '' 'fzf_open_app')" \
--bind 'f12:execute-silent(echo "open /Applications/{}"| pbcopy)+abort'
}
alias foa="fzf_open_app"                                                            # Desc: alias: foa: fzf_open_appå‘½ä»¤çš„åˆ«å,åˆ©ç”¨fzfé€šè¿‡ç»ˆç«¯æ‰“å¼€App

# macOS åº”ç”¨å¯åŠ¨å™¨
function fzf_fuzzy_launch() {                                                       # Desc: function: fzf_fuzzy_launch: åˆ©ç”¨fzfé€šè¿‡ç»ˆç«¯æ‰“å¼€App
    mdfind kMDItemContentTypeTree=com.apple.application-bundle -onlyin /Applications \
    | fzf --height 40% --reverse --preview 'mdls -name kMDItemDisplayName -name kMDItemVersion -name kMDItemLastUsedDate {}' \
    | xargs -o open
}
alias foa2="fzf_fuzzy_launch"                                                       # Desc: alias: foa2: fzf_fuzzy_launchå‘½ä»¤çš„åˆ«å,åˆ©ç”¨fzfé€šè¿‡ç»ˆç«¯æ‰“å¼€App

function cp_forward() {                                                             # Desc: function: cp_forward: cpå¤åˆ¶å®Œæˆåè·³è½¬è‡³ç›®å½•
    cp "$@" && go2 "$_";
}
alias cpf="cp_forward"                                                              # Desc: alias: cpf:cp_forwardå‘½ä»¤çš„åˆ«å,cpå¤åˆ¶å®Œæˆåè·³è½¬è‡³ç›®å½•

function mv_forward() {                                                             # Desc: function: mv_forward: mvç§»åŠ¨å®Œæˆåè·³è½¬è‡³ç›®å½•
    mv "$@" && go2 "$_";
}
alias mvf="mv_forward"                                                              # Desc: alias: mvf:mv_forwardå‘½ä»¤çš„åˆ«å,mvç§»åŠ¨å®Œæˆåè·³è½¬è‡³ç›®å½•

function mkdir_forward() {                                                          # Desc: function: mkdir_forward: mkdiråˆ›å»ºç›®å½•å®Œæˆåè·³è½¬è‡³ç›®å½•
    mkdir -p $1; cd $1
}
alias mkf="mkdir_forward"                                                           # Desc: alias: mkf: mkdir_forwardå‘½ä»¤çš„åˆ«å,mkdiråˆ›å»ºç›®å½•å®Œæˆåè·³è½¬è‡³ç›®å½•

function fzf_most_used_command() {                                                  # Desc: function: fzf_most_used_command:å†å²æ“ä½œä¸­ä½¿ç”¨æœ€å¤šçš„50ä¸ªå‘½ä»¤
    #é™¤äº†historyå¤–,åœ¨omzä¸­å¯ä»¥ä½¿ç”¨:omz_history -n | sed 's/^[[:space:]]*//g' | sed 's/^[0-9]*//g' | sed 's/^[[:space:]]*//g' | sort | uniq -c | sort -n -k1 | tail -30 | tac
    history | sed 's/^[[:space:]]\{0,\}[0-9]\{1,\}//g' | sed 's/^[[:space:]]*//g' | sed 's/^[[:space:]]\{0,\}[0-9]\{1,\}//g' | sed 's/^[[:space:]]*//g' | sort | uniq -c | sort -n -k1 | tail -50 | tac |fzf $FZF_CUSTOM_PARAMS --no-sort \
--preview-window right:70%:rounded:hidden:wrap \
--preview 'echo {} | awk "{\$1=\"\";print}"' \
--border-label='â•¢ ğŸ‘£ History â•Ÿ' \
--header-label='â•¢ ğŸ‘£ History â•Ÿ' \
--bind 'enter:become(echo {} | awk "{\$1=\"\";print}")' \
--bind 'focus:transform-preview-label:echo -n "[ {1} ]";' \
--header="$(_buildFzfHeader '' 'fzf_most_used_command')" \
--bind 'f12:execute-silent(echo {} | awk "{\$1=\"\";print}" | pbcopy)+abort'
}
alias fmu="fzf_most_used_command"                                                   # Desc: alias: fmu: fzf_most_used_commandå‘½ä»¤çš„åˆ«å,å†å²æ“ä½œä¸­ä½¿ç”¨æœ€å¤šçš„50ä¸ªå‘½ä»¤

function fzf_manage() {                                                             # Desc: function: fzf_manage: åˆ©ç”¨fzfç®¡ç†ç›®å½•ä¸‹çš„å­æ–‡ä»¶å¤¹ã€æ–‡ä»¶ã€å›¾ç‰‡ç­‰
    local ACTIONCOMMAND
    if [[ $(ifHasCommand gum) = 1 ]]; then
        ACTIONCOMMAND='gum confirm "ç¡®è®¤åˆ é™¤?" && rm -f '
    else
        ACTIONCOMMAND='rm -f '
    fi
    fd --max-depth 1 -H --exclude={.git,.idea,.vscode,.sass-cache,node_modules,build} | fzf $FZF_CUSTOM_PARAMS \
    --bind "ctrl-d:execute($ACTIONCOMMAND {})+reload(ls || true)" \
    --bind "change:reload:sleep 0.1; fd --max-depth 1 -H --exclude={.git,.idea,.vscode,.sass-cache,node_modules,build} || true" \
    --bind "ctrl-r:execute-silent(open -R {})" \
    --bind "ctrl-f:transform:$fzf_transformer_search_swap_type" \
    --header="$(_buildFzfHeader '' 'fzf_manage')" \
    --preview-window right:70%:rounded:hidden:wrap --preview " $MYRUNTIME/customs/bin/_previewer {} "
}
alias fm2="fzf_manage"                                                              # Desc: alias: fm2: fzf_manageå‘½ä»¤çš„åˆ«å,åˆ©ç”¨fzfç®¡ç†ç›®å½•ä¸‹çš„å­æ–‡ä»¶å¤¹ã€æ–‡ä»¶ã€å›¾ç‰‡ç­‰

function open_directory_whereis_command() {                                         # Desc: function: open_directory_whereis_command:æ‰“å¼€whichå‘½ä»¤æ‰¾åˆ°çš„ç›®å½•æˆ–æ–‡ä»¶
    hascommand=$(ifHasCommand $@)
    [[ $hascommand != 1 ]] && echo "Command $@ does not exists !" && return 1
    if [ "$(type $1 | grep 'a shell function from')" = "" ] && [ "$(type $1 | grep 'is an alias for')" = "" ]; then
        open `dirname $(which "$1")`
    else
        endfile=$(type "$1" | awk '{print $NF}')
        if [ -f $endfile ] || [ -d $endfile ]; then
            open $(dirname $endfile)
        else
            open_directory_whereis_command $endfile
        fi
    fi
}
alias openw="open_directory_whereis_command"                                        # Desc: alias: openw:open_directory_whereis_commandå‘½ä»¤çš„åˆ«å,æ‰“å¼€whichå‘½ä»¤æ‰¾åˆ°çš„ç›®å½•æˆ–æ–‡ä»¶

function cd_parent_directory_by_which_command() {                                   # Desc: function: cd_parent_directory_by_which_command:è¿›å…¥å‘½ä»¤æ‰€åœ¨çš„çˆ¶çº§æ–‡ä»¶å¤¹
    hascommand=$(ifHasCommand $@)
    [[ $hascommand != 1 ]] && echo "Command $@ does not exists !" && return 1
    if [ "$(type $1 | grep 'a shell function from')" = "" ] && [ "$(type $1 | grep 'is an alias for')" = "" ]; then
        cd `dirname $(dirname $(which "$1"))`
    else
        endfile=$(type "$1" | awk '{print $NF}')
        if [ -f $endfile ]; then
            cd $(dirname $(dirname $endfile))
        else
            cd_parent_directory_by_which_command $endfile
        fi
    fi
}
alias cdpw="cd_parent_directory_by_which_command"                                   # Desc: alias: cdpw:cd_parent_directory_by_which_commandå‘½ä»¤çš„åˆ«å,è¿›å…¥å‘½ä»¤æ‰€åœ¨çš„çˆ¶çº§æ–‡ä»¶å¤¹

function cd_directory_by_which_command() {                                          # Desc: function: cd_directory_by_which_command:è¿›å…¥å‘½ä»¤æ‰€åœ¨çš„æ–‡ä»¶å¤¹
    [[ -f $1 ]] && cd $(dirname $1) && return 1
    [[ -d $1 ]] && cd $1 && return 1
    hascommand=$(ifHasCommand $@)
    [[ $hascommand != 1 ]] && echo "Command $@ does not exists !" && return 1
    if [ "$(type $1 | grep 'a shell function from')" = "" ] && [ "$(type $1 | grep 'is an alias for')" = "" ]; then
        cd `dirname $(which "$1")`
    else
        endfile=$(type "$1" | awk '{print $NF}')
        if [ -f $endfile ]; then
            cd $(dirname $endfile)
        else
            cd_directory_by_which_command $endfile
        fi
    fi
}
alias cdw="cd_directory_by_which_command"                                           # Desc: alias: cdw:cd_directory_by_which_commandå‘½ä»¤çš„åˆ«å,è¿›å…¥å‘½ä»¤æ‰€åœ¨çš„æ–‡ä»¶å¤¹

function action_which() {                                                           # Desc: function: action_which:ç”¨whichå‘½ä»¤æ‰¾å‡ºæ–‡ä»¶æˆ–å‘½ä»¤çš„ä½ç½®,å¹¶ç”¨å‚æ•°ä¸­çš„å‘½ä»¤æ“ä½œ
    local COMMANDBIN="$1"
    local TMPFILEPATH=$(pwd)
    [[ "" = "$1" ]] && echo "Command is empty !" && return 1
    [[ "" != "$2" ]] && TMPFILEPATH="$2"
    
    if [ -d $TMPFILEPATH ] || [ -f $TMPFILEPATH ]; then
        eval "$COMMANDBIN $TMPFILEPATH"
        return
    elif [ "$(type $TMPFILEPATH | grep 'a shell function from')" != "" ] || [ "$(type $TMPFILEPATH | grep 'is an alias for')" != "" ] || [ "$(type $TMPFILEPATH | grep 'is a shell builtin')" != "" ]; then
        endfile=$(type "$TMPFILEPATH" | awk '{print $NF}')
        if [ "$endfile" = "builtin" ]; then
            echo "$TMPFILEPATH is a shell builtin !"
            echo "Chanel ..."
            return 1
        elif [ -f "$endfile" ] || [ -d "$endfile" ]; then
            eval "$COMMANDBIN $endfile"
            return
        else
            action_which "$COMMANDBIN" "$endfile"
            return
        fi
    else
        # å¦‚æœ TMPFILEPATH æ˜¯ä¸€ä¸ªæ™®é€šå‘½ä»¤ï¼Œç›´æ¥æ‰§è¡Œ
        eval "$COMMANDBIN $(which "$TMPFILEPATH")"
        return
    fi
}
alias aw="action_which"                                                             # Desc: alias: aw: action_whichå‘½ä»¤çš„åˆ«å,ç”¨whichå‘½ä»¤æ‰¾å‡ºæ–‡ä»¶æˆ–å‘½ä»¤çš„ä½ç½®,å¹¶ç”¨å‚æ•°ä¸­çš„å‘½ä»¤æ“ä½œ

function get_which_command_directory() {                                            # Desc: function: get_which_command_directory:è·å–å‘½ä»¤æ‰€åœ¨ç›®å½•
    local COMMANDBIN="/usr/bin/dirname"
    action_which $COMMANDBIN $1
}
alias dirw="get_which_command_directory"                                            # Desc: alias: dirw:get_which_command_directoryå‘½ä»¤çš„åˆ«å,è·å–å‘½ä»¤æ‰€åœ¨ç›®å½•
alias pwdw="get_which_command_directory"                                            # Desc: alias: pwdw:get_which_command_directoryå‘½ä»¤çš„åˆ«å,è·å–å‘½ä»¤æ‰€åœ¨çš„æ–‡ä»¶å¤¹

function code_which() {                                                             # Desc: function: code_which:visual studio code ç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
    local COMMANDBIN="/usr/local/bin/code"
    action_which $COMMANDBIN $1
}
alias cw="code_which"                                                               # Desc: alias: cw: code_whichå‘½ä»¤çš„åˆ«å,visualstudio codeç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
alias codew="code_which"                                                            # Desc: alias: codew: code_whichå‘½ä»¤çš„åˆ«å,visualstudio codeç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€

function sublime_text_which() {                                                     # Desc: function: sublime_text_which:sublimetextç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
    local COMMANDBIN="$HOME/bin/subl"
    action_which $COMMANDBIN $1
}
alias sw="sublime_text_which"                                                       # Desc: alias: sw:sublime_text_whichå‘½ä»¤çš„åˆ«å,sublimetextç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
alias stw="sublime_text_which"                                                      # Desc: alias: stw:sublime_text_whichå‘½ä»¤çš„åˆ«å,sublimetextç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€

function vim_which() {                                                              # Desc: function: vim_which:vimç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
    if [ -f /usr/local/bin/vim ]; then
        local COMMANDBIN="/usr/local/bin/vim"
    elif [ -f /opt/homebrew/bin/vim ]; then
        local COMMANDBIN="/opt/homebrew/bin/vim"
    fi
    action_which $COMMANDBIN $1
}
alias vw="vim_which"                                                                # Desc: alias: vw: vim_whichå‘½ä»¤çš„åˆ«å,vimç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
alias viw="vim_which"                                                               # Desc: alias: viw: vim_whichå‘½ä»¤çš„åˆ«å,vimç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€

function neovim_which() {                                                           # Desc: function: neovim_which:neovimç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
    if [ -f /usr/local/bin/nvim ]; then
        local COMMANDBIN="/usr/local/bin/nvim"
    elif [ -f /opt/homebrew/bin/nvim ]; then
        local COMMANDBIN="/opt/homebrew/bin/nvim"
    fi
    action_which $COMMANDBIN $1
}
alias nw="neovim_which"                                                             # Desc: alias: nw: neovim_whichå‘½ä»¤çš„åˆ«å,neovimç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
alias nviw="neovim_which"                                                           # Desc: alias: nviw: neovim_whichå‘½ä»¤çš„åˆ«å,neovimç¼–è¾‘whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€

function head_whereis_file() {                                                      # Desc: function: headw:headå‘½ä»¤æ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
    local COMMANDBIN="/usr/bin/head"
    action_which $COMMANDBIN $1
}
alias headw="head_whereis_file"                                                     # Desc: alias: headw:head_whereis_fileå‘½ä»¤çš„åˆ«å,headå‘½ä»¤æ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€

function tail_whereis_file() {                                                      # Desc: function: tail_whereis_file:tailå‘½ä»¤æ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
    local lines=50
    [[ "" != "$2" ]] && lines="$2"
    local COMMANDBIN="/usr/bin/tail -n $lines"
    action_which $COMMANDBIN $1
}
alias tailw="tail_whereis_file"                                                     # Desc: alias: tailw:tail_whereis_fileå‘½ä»¤çš„åˆ«å,tailå‘½ä»¤æ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€

function cat_whereis_file() {                                                       # Desc: function: cat_whereis_file:catæ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
    local COMMANDBIN="/bin/cat"
    [[ -f /usr/local/bin/ccat ]] && COMMANDBIN="/usr/local/bin/ccat"
    [[ -f /opt/homebrew/bin/ccat ]] && COMMANDBIN="/opt/homebrew/bin/ccat"
    action_which $COMMANDBIN $1
}
alias catw="cat_whereis_file"                                                       # Desc: alias: catw:cat_whereis_fileå‘½ä»¤çš„åˆ«å,catæ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€

function bat_whereis_file() {                                                       # Desc: function: bat_whereis_file:batå‘½ä»¤æ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
    [[ -f /usr/local/bin/bat ]] && COMMANDBIN="/usr/local/bin/bat"
    [[ -f /opt/homebrew/bin/bat ]] && COMMANDBIN="/opt/homebrew/bin/bat"
    action_which $COMMANDBIN $1
}
alias batw="bat_whereis_file"                                                       # Desc: alias: batw:bat_whereis_fileå‘½ä»¤çš„åˆ«å,batå‘½ä»¤æ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€

function type_whereis_file() {                                                      # Desc: function: type_whereis_file:typeå‘½ä»¤æ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
    local COMMANDBIN="/usr/bin/type"
    action_which $COMMANDBIN $1
}
alias typew="type_whereis_file"                                                     # Desc: alias: typew:type_whereis_fileå‘½ä»¤çš„åˆ«å,typeå‘½ä»¤æ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€

function ll_whereis_command() {                                                     # Desc: function: ll_whereis_command:æ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€
    local COMMANDBIN="/bin/ls -l"
    action_which $COMMANDBIN $1
}
alias llw="ll_whereis_command"                                                      # Desc: alias: llw:ll_whereis_commandå‘½ä»¤çš„åˆ«å,æ‰“å°whichå‘½ä»¤æ‰¾åˆ°çš„æ–‡ä»¶åœ°å€

function fzf_search_custom_functions_by_desc() {                                    # Desc: function: fzf_search_custom_functions_by_desc:æ ¹æ®è‡ªå®šä¹‰çš„æè¿°å’Œå‡½æ•°åæŸ¥è¯¢è‡ªå®šä¹‰å‘½ä»¤
    TMP_FUNCTIONS_FILE=$(mktemp)
    local COMMANDPATH=$MYRUNTIME/customs/my_shell/
    find $COMMANDPATH -type f -name "*.bzsh" |xargs grep 'Desc: function:' | grep -v 'TMP_FUNCTIONS_FILE' > $TMP_FUNCTIONS_FILE
    if [ -f $TMP_FUNCTIONS_FILE ] && [ "" != "$(cat $TMP_FUNCTIONS_FILE)" ]; then
        local CHOOSE=$(cat $TMP_FUNCTIONS_FILE | awk -F'# Desc: function:' '{print $2}' | fzf $FZF_CUSTOM_PARAMS \
        --preview-window right:70%:rounded:hidden:wrap \
        --preview "echo {} | sed 's/:/\\n/g'" \
        --delimiter ':' \
        --bind "enter:become(echo {1})" \
        --bind 'f12:execute-silent(echo -n {1}| pbcopy)+abort' \
        --header="$(_buildFzfHeader '' 'fzf_search_custom_functions_by_desc')" \
        --bind "ctrl-e:execute(bat $TMP_FUNCTIONS_FILE > /dev/tty)")
        if [ "" != "$CHOOSE" ]; then
            echo "$CHOOSE"
            echo ""
            eval "$CHOOSE"
        fi
        rm -f $TMP_FUNCTIONS_FILE
    fi
}
alias fsf="fzf_search_custom_functions_by_desc"                                     # Desc: alias: fsf: fzf_search_custom_functions_by_descå‘½ä»¤çš„åˆ«å,æ ¹æ®è‡ªå®šä¹‰çš„æè¿°å’Œå‡½æ•°åæŸ¥è¯¢è‡ªå®šä¹‰å‘½ä»¤

function fzf_search_custom_alias_by_desc() {                                        # Desc: function: fzf_search_custom_alias_by_desc:æ ¹æ®è‡ªå®šä¹‰çš„æè¿°å’Œåˆ«åæŸ¥è¯¢è‡ªå®šä¹‰å‘½ä»¤
    TMP_ALIAS_FILE=$(mktemp)
    local COMMANDPATH=$MYRUNTIME/customs/my_shell/
    find $COMMANDPATH -type f -name "*.bzsh" |xargs grep 'Desc: alias:' | grep -v 'TMP_ALIAS_FILE' > $TMP_ALIAS_FILE
    if [ -f $TMP_ALIAS_FILE ] && [ "" != "$(cat $TMP_ALIAS_FILE)" ]; then
        local CHOOSE=$(cat $TMP_ALIAS_FILE | awk -F'# Desc: alias:' '{print $2}' | fzf $FZF_CUSTOM_PARAMS \
        --preview-window right:70%:rounded:hidden:wrap \
        --preview "echo {} | sed 's/:/\\n/g'" \
        --delimiter ':' \
        --bind "enter:become(echo {1})" \
        --bind 'f12:execute-silent(echo -n {1}| pbcopy)+abort' \
        --header="$(_buildFzfHeader '' 'fzf_search_custom_alias_by_desc')" \
        --bind "ctrl-e:execute(bat $TMP_ALIAS_FILE > /dev/tty)")
        if [ "" != "$CHOOSE" ]; then
            echo "$CHOOSE"
            echo ""
            eval "$CHOOSE"
        fi
        rm -f $TMP_ALIAS_FILE
    fi
}
alias fsa="fzf_search_custom_alias_by_desc"                                         # Desc: alias: fsa: fzf_search_custom_alias_by_descå‘½ä»¤çš„åˆ«å,æ ¹æ®è‡ªå®šä¹‰çš„æè¿°å’Œåˆ«åæŸ¥è¯¢è‡ªå®šä¹‰å‘½ä»¤

function fzf_view_bookmarks_list() {                                                # Desc: function: fzf_view_bookmarks_list: åˆ©ç”¨fzfæŸ¥çœ‹ç»ˆç«¯æ”¶è—
    local ifbreak="${1:-0}"
    cd ${TMP_FZF_BOOKMARKS_PATH}/ 
    local selected=$(ls . | fzf $FZF_CUSTOM_PARAMS +m \
    --bind="ctrl-d:execute(rm -f ${TMP_FZF_BOOKMARKS_PATH}/{})+reload(ls .)" \
    --header="$(_buildFzfHeader '' 'fzf_view_bookmarks_list')" \
    --preview-window="right:70%:border-rounded,nohidden,~3" \
    --preview="(${MYRUNTIME}/customs/bin/_previewer ${TMP_FZF_BOOKMARKS_PATH}/{}) 2> /dev/null | head -500")
    cd -
    if [ "" != "${selected}" ]; then
        head -n 1 ${TMP_FZF_BOOKMARKS_PATH}/${selected} | pbcopy
    fi
    if [ "$ifbreak" != "0" ]; then
        break 2
    fi
    return 1
}
alias fvb="fzf_view_bookmarks_list"                                                 # Desc: alias: fvb: fzf_view_bookmarks_listå‘½ä»¤çš„åˆ«åï¼Œåˆ©ç”¨fzfæŸ¥çœ‹ç»ˆç«¯æ”¶è—

function get_iterm2_current_background_image() {                                    # Desc: function: get_iterm2_current_background_image: è·å–å½“å‰itermçš„sessionä¸­èƒŒæ™¯å›¾åœ°å€
    bg_path=$(osascript -e '
tell application "iTerm"
    if current window is missing value then
        return ""
    end if
    
    tell current window
        if current session is missing value then
            return ""
        end if
        
        tell current session
            if background image is not missing value then
                return background image
            else
                return ""
            end if
        end tell
    end tell
end tell')

    # æ£€æŸ¥ç»“æœ
    if [[ -n "$bg_path" && "$bg_path" != "missing value" ]]; then
        echo "$bg_path"
    fi
    return
}
alias gicbg="get_iterm2_current_background_image"                                   # Desc: alias: gicbg: get_iterm2_current_background_imageå‘½ä»¤çš„åˆ«åï¼Œè·å–å½“å‰itermçš„sessionä¸­èƒŒæ™¯å›¾åœ°å€

function fzf_full_files_manager() {                                                 # Desc: function: fzf_full_files_manager:åˆ©ç”¨fzfç®¡ç†æ–‡ä»¶å¤¹ã€æ–‡ä»¶ã€å›¾ç‰‡ã€æ–‡æœ¬æœç´¢ã€å½±éŸ³æ–‡ä»¶ç­‰
    ___fzf_manage_all() {
        local Action="$1"
        local Varname="fzf_transformer_filter_$Action"
        local Cmd=$fzf_transformer_filter_all
        local Operate
        echo "$Action" > $TMP_FZF_SEARCH_SWAP_FILE
        [[ -n "$BASH_VERSION" ]] && Cmd="${!Varname}"
        [[ -n "$ZSH_VERSION" ]] && Cmd="${(P)Varname}"
        Operate=$(eval "$Cmd" | fzf $FZF_CUSTOM_PARAMS +m \
        --preview "(${MYRUNTIME}/customs/bin/_previewer {}) 2> /dev/null | head -500" \
        --header="$(_buildFzfHeader '' 'fzf_full_files_manager')" )
        if [ "" != "$Operate" ]; then
            if [ "$Action" = "contents" ]; then
                local tmpfilepath=$(echo "$Operate" | awk -F':' '{print $1}')
                local tmplinenum=$(echo "$Operate" | awk -F':' '{print $2}')
                if command -v code > /dev/null; then
                    /usr/local/bin/code --new-window --goto ${tmpfilepath}:${tmplinenum}
                elif command -v nvim > /dev/null; then
                    nvim +${tmplinenum} ${tmpfilepath}
                elif command -v vim > /dev/null; then
                    vim  +${tmplinenum} ${tmpfilepath}
                else
                    bat --highlight-line="${tmplinenum}" --theme=gruvbox-dark --style='full' --color=always --pager=never "${tmpfilepath}"
                fi
            else
                echo $Operate
            fi
        else
            return
        fi
    }

    while true; do
        local action=$(printf "%s\n" \
            $(if [ "$TERM_PROGRAM" = "iTerm.app" ] && [ "" != "$(get_iterm2_current_background_image)" ]; then echo "æ”¶è—èƒŒæ™¯å›¾ï¼ˆcollectionï¼‰"; fi) \
            "ğŸ”ï¸ æ‰€æœ‰æ–‡ä»¶(All)" \
            "ğŸ“‚ æ–‡ä»¶å¤¹(Directory)" \
            "ğŸ“„ æ–‡ä»¶(File)" \
            "ğŸ¥· éšè—æ–‡ä»¶(Hidden)" \
            "ğŸ–¼ï¸ å›¾ç‰‡(Image)" \
            "ğŸ“– æ–‡æœ¬(Document)" \
            "ğŸ“»ï¸ åª’ä½“(Media)" \
            "ğŸ§¾ å¼€å‘(Develop)" \
            "ğŸ“ å…¨æ–‡æœç´¢(Content)" \
            "ğŸ—œï¸ å‹ç¼©æ–‡ä»¶(Archive)" \
            "â„¢ï¸ è‡ªå®šä¹‰FZFå‡½æ•°(Function)" \
            "Â®ï¸ è‡ªå®šä¹‰å‡½æ•°(Function)" \
            "Â©ï¸ è‡ªå®šä¹‰åˆ«å(Alia)" \
            "ğŸ—ƒï¸ æŸ¥çœ‹ä¹¦ç­¾(BookMark)" \
            "ğŸ”š é€€å‡ºç³»ç»Ÿ(Exit)" | \
            fzf +m \
                --header " æ–‡ä»¶ç®¡ç†ç³»ç»Ÿ " \
                --prompt "ä¸»èœå• â¯ " \
                --preview-window=up:30% \
                --preview "echo 'è¯·é€‰æ‹©æ“ä½œç±»å‹'" \
                --height=15% \
                --bind='space:jump,jump:accept' \
                --reverse)

        case $action in
            *æ”¶è—èƒŒæ™¯å›¾*) 
                $MYRUNTIME/customs/bin/favo add
                return 
                ;;
            *æ‰€æœ‰æ–‡ä»¶*) ___fzf_manage_all "all" ;;
            *æ–‡ä»¶å¤¹*) ___fzf_manage_all "directories" ;;
            *éšè—æ–‡ä»¶*) ___fzf_manage_all "hiddens" ;;
            *å‹ç¼©æ–‡ä»¶*) ___fzf_manage_all "archives" ;;
            *æ–‡ä»¶*) ___fzf_manage_all "files" ;;
            *å›¾ç‰‡*) ___fzf_manage_all "images" ;;
            *æ–‡æœ¬*) ___fzf_manage_all "documents" ;;
            *åª’ä½“*) ___fzf_manage_all "medias" ;;
            *å¼€å‘*) ___fzf_manage_all "languages" ;;
            *å…¨æ–‡æœç´¢*) ___fzf_manage_all "contents" ;;
            *è‡ªå®šä¹‰FZFå‡½æ•°*) fzf_customs_fzf_awesome_functions_list ;;
            *è‡ªå®šä¹‰å‡½æ•°*) fzf_search_custom_functions_by_desc ;;
            *è‡ªå®šä¹‰åˆ«å*) fzf_search_custom_alias_by_desc ;;
            *æŸ¥çœ‹ä¹¦ç­¾*) fzf_view_bookmarks_list 1;;
            *é€€å‡ºç³»ç»Ÿ*) break 1 && return ;;
        esac
    done
}
alias ffm="fzf_full_files_manager"                                                  # Desc: alias: ffm: fzf_full_files_managerå‘½ä»¤çš„åˆ«å,åˆ©ç”¨fzfç®¡ç†æ–‡ä»¶å¤¹ã€æ–‡ä»¶ã€å›¾ç‰‡ã€æ–‡æœ¬æœç´¢ã€å½±éŸ³æ–‡ä»¶ç­‰

if [ "zsh" = "$nowshell" ]; then
    zle -N fzf_full_files_manager
    bindkey '^F' fzf_full_files_manager   #//Ctrl F æ‰§è¡Œfzf_full_files_managerå‡½æ•°
else
    export -f fzf_full_files_manager
    bind '"\C-F":"fzf_full_files_manager;\n"'   #//Ctrl F æ‰§è¡Œfzf_full_files_managerå‡½æ•°
fi

function brew_services_manage() {                                                   # Desc: function: brew_service_manage:brew servicesæœåŠ¡å‘½ä»¤ç®¡ç†å™¨
    local options=("start" "restart" "stop" "status" "run" "list" "cleanup" "-h" "--help")
    local myservice=$1
    local myoption=$2
    local ismysql="true"
    if [ "$myservice" != "mysql" ] && [ "$myservice" != "mysqladmin" ] && [[ $myservice != mysql* ]]; then
        ismysql=""
    fi

    custom_title() {
        local title=$1
        if [ "" = "$title" ]; then
            title=""
        fi
        echo "â”‚    $title \n" | lolcat -f
        return 0
    }

    if [[ $# -lt 1 ]]; then
        local services=$(brew services list | awk '{print $1}' | grep -v 'Name')

        echo ""
        custom_title "Installed services:"

        echo "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚" | lolcat -f
        for service in $(echo $services | awk '{print $1}' | grep -v 'Name'); do
            echo "â”‚    $service  " | lolcat -f
        done
        echo "â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n" | lolcat -f

        echo ""
        custom_title "Suppose options:"
        echo "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚" | lolcat -f
        echo -n "â”‚   " | lolcat -f
        for option_i in ${options[*]}; do
            echo -n "[ $option_i ] " | lolcat -f
        done

        echo "\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n" | lolcat -f

        echo ""
        custom_title "Help:"

        echo "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚   
â”‚   brew_services_manage [service_name] [list | run | start | stop | restart | cleanup]
â”‚   Easily start and stop formulae via launchctl.
â”‚
â”‚   Integrates Homebrew formulae with macOS' launchctl manager. Services can be
â”‚   added to either /Library/LaunchDaemons or ~/Library/LaunchAgents.
â”‚   Basically, items in /Library/LaunchDaemons are started at boot, while those
â”‚   in ~/Library/LaunchAgents are started at login.
â”‚
â”‚   When started with sudo, it operates on /Library/LaunchDaemons; otherwise,
â”‚   it operates on ~/Library/LaunchAgents.
â”‚
â”‚   On start the plist file is generated and written to a Tempfile, and then
â”‚   copied to the launch path (existing plists are overwritten).
â”‚
â”‚   [sudo] brew_services_manage list
â”‚   List all running services for the current user (or root)
â”‚
â”‚   [sudo] brew_services_manage formula|--all run
â”‚   Run the service formula without starting at login (or boot).
â”‚
â”‚   [sudo] brew_services_manage formula|--all start
â”‚   Start the service formula immediately and register it to launch at login (or boot).
â”‚
â”‚   [sudo] brew_services_manage formula|--all stop
â”‚   Stop the service formula immediately and unregister it from launching at login (or boot).
â”‚
â”‚   [sudo] brew_services_manage formula|--all restart
â”‚   Stop (if necessary) and start the service immediately and register it to launch at login (or boot).
â”‚   \nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n" | lolcat -f
        return 1
    elif [ "status" = "$1" ]; then
        brew services list | lolcat -f
    else
        #******************************************************************#
        # mysql å¯åŠ¨ä¸é‡å¯ç‹¬ç«‹å¤„ç†
        #******************************************************************#
        if [ "$ismysql" = "true" ]; then
            echo "å¦‚æœmysqlå‡ºç°é—®é¢˜ï¼Œéœ€è¦æ›´æ”¹plistæ–‡ä»¶ï¼Œè¿›å…¥mysqlçš„baseç›®å½• ä¿®æ”¹ç›®å½•ä¸‹çš„plistæ–‡ä»¶å³å¯"
            if [ "$myoption" = "start" ] || [ "$myoption" = "restart" ]; then
                [[ "intel64" = "$CPUCORE" ]] && [[ -f /usr/local/etc/my.cnf ]] && rm -f /usr/local/etc/my.cnf
                [[ "arm64" = "$CPUCORE" ]] && [[ -f /opt/homebrew/etc/my.cnf ]] && rm -f /opt/homebrew/etc/my.cnf
                [[ -L /private/etc/my.cnf ]] && sudo rm -f /private/etc/my.cnf
                case "$myservice" in
                "mysql") #é»˜è®¤9.0
                    if [ -d /usr/local/etc/ ] && [ "intel64" = "$CPUCORE" ]; then
                        ln -sf $HOME/Dropbox/working/coding/conf/mysql/9.0/my.cnf /usr/local/etc/my.cnf
                        sudo ln -sf $HOME/Dropbox/working/coding/conf/mysql/9.0/my.cnf /private/etc/my.cnf
                    fi
                    if [ -d /opt/homebrew/etc/ ] && [ "arm64" = "$CPUCORE" ]; then
                        ln -sf $HOME/Dropbox/working/coding/conf/mysql_arm64/9.0/my.cnf /opt/homebrew/etc/my.cnf
                        sudo ln -sf $HOME/Dropbox/working/coding/conf/mysql_arm64/9.0/my.cnf /private/etc/my.cnf
                    fi
                    ;;
                "mysql@8.0")
                    if [ -d /usr/local/etc/ ] && [ "intel64" = "$CPUCORE" ]; then
                        ln -sf $HOME/Dropbox/working/coding/conf/mysql/8.0/my.cnf /usr/local/etc/my.cnf
                        sudo ln -sf $HOME/Dropbox/working/coding/conf/mysql/8.0/my.cnf /private/etc/my.cnf
                    fi
                    if [ -d /opt/homebrew/etc/ ] && [ "arm64" = "$CPUCORE" ]; then
                        ln -sf $HOME/Dropbox/working/coding/conf/mysql_arm64/8.0/my.cnf /opt/homebrew/etc/my.cnf
                        sudo ln -sf $HOME/Dropbox/working/coding/conf/mysql_arm64/8.0/my.cnf /private/etc/my.cnf
                    fi
                    ;;
                "mysql@5.5")
                    if [ -d /usr/local/etc/ ] && [ "intel64" = "$CPUCORE" ]; then
                        ln -sf $HOME/Dropbox/working/coding/conf/mysql/5.5/my.cnf /usr/local/etc/my.cnf
                        sudo ln -sf $HOME/Dropbox/working/coding/conf/mysql/5.5/my.cnf /private/etc/my.cnf
                    fi
                    ;;
                "mysql@5.6")
                    if [ -d /usr/local/etc/ ] && [ "intel64" = "$CPUCORE" ]; then
                        ln -sf $HOME/Dropbox/working/coding/conf/mysql/5.6/my.cnf /usr/local/etc/my.cnf
                        sudo ln -sf $HOME/Dropbox/working/coding/conf/mysql/5.6/my.cnf /private/etc/my.cnf
                    fi
                    ;;
                "mysql@5.7")
                    if [ -d /usr/local/etc/ ] && [ "intel64" = "$CPUCORE" ]; then
                        ln -sf $HOME/Dropbox/working/coding/conf/mysql/5.7/my.cnf /usr/local/etc/my.cnf
                        sudo ln -sf $HOME/Dropbox/working/coding/conf/mysql/5.7/my.cnf /private/etc/my.cnf
                    fi
                    if [ -d /opt/homebrew/etc/ ] && [ "arm64" = "$CPUCORE" ]; then
                        ln -sf $HOME/Dropbox/working/coding/conf/mysql_arm64/5.7/my.cnf /opt/homebrew/etc/my.cnf
                        sudo ln -sf $HOME/Dropbox/working/coding/conf/mysql_arm64/5.7/my.cnf /private/etc/my.cnf
                    fi
                    ;;
                esac
            fi

            if [ "$myoption" = "stop" ]; then
                [[ "intel64" = "$CPUCORE" ]] && [[ -f /usr/local/etc/my.cnf ]] && rm -f /usr/local/etc/my.cnf
                [[ "arm64" = "$CPUCORE" ]] && [[ -f /opt/homebrew/etc/my.cnf ]] && rm -f /opt/homebrew/etc/my.cnf
                [[ -L /private/etc/my.cnf ]] && sudo rm -f /private/etc/my.cnf
            fi
        fi
        #******************************************************************#
        # mysql å¯åŠ¨ä¸é‡å¯ç‹¬ç«‹å¤„ç† end
        #******************************************************************#

        case "$myoption" in
        "status")
            echo "brew services list| grep \"Name\|$myservice\""
            custom_title "Result:"
            echo ""
            brew services list | grep "Name\|$myservice"
            ;;
        "fullprocesslist")
            if [ "$ismysql" = "true" ]; then
                [[ -f $MYRUNTIME/tools/m_mysql ]] && source $MYRUNTIME/tools/m_mysql || echo "ERROR: m_mysql does not exists!"
                custom_title "mysql -u$user -p$pass -h$host -P$port -e 'show full processlist'"
                echo ""
                custom_title "Result:"
                echo ""
                for ((i = 1; i <= 10; i++)); do
                    echo $i
                    mysql -u$user -p"$pass" -h$host -P$port -e 'show full processlist'
                    # sleep 1
                done
            else
                echo ""
                custom_title "Result:"
                echo ""
                echo "Not suppose yet!"
            fi
            ;;
        "processlist")
            if [ "$ismysql" = "true" ]; then
                [[ -f $MYRUNTIME/tools/m_mysql ]] && source $MYRUNTIME/tools/m_mysql || echo "ERROR: m_mysql does not exists!"
                custom_title "mysqladmin -u$user -p"$pass" -h$host -P$port processlist -i 1"
                echo ""
                custom_title "Result:"
                echo ""
                mysqladmin -u$user -p$pass -h$host -P$port processlist -i 1
            else
                echo ""
                custom_title "Result:"
                echo ""
                echo "Not suppose yet!"
            fi
            ;;
        "login")
            if [ "$myservice" = "mysqladmin" ]; then
                [[ -f $MYRUNTIME/tools/m_mysqladmin ]] && source $MYRUNTIME/tools/m_mysqladmin || echo "ERROR: m_mysqladmin does not exists!"
                custom_title "mysql -u$user -p$pass -h$host -P$port"
                echo ""
                custom_title "Result:"
                echo ""
                mysql -u$user -p$pass -h$host -P$port
            elif [ "$ismysql" = "true" ]; then
                [[ -f $MYRUNTIME/tools/m_mysql ]] && source $MYRUNTIME/tools/m_mysql || echo "ERROR: m_mysql does not exists!"
                custom_title "mycli -u$user -p$pass -h$host -P$port"
                echo ""
                custom_title "Result:"
                echo ""
                mycli -u$user -p"$pass" -h$host -P$port --myclirc=$myclirc
            elif [ "$myservice" = "redis" ]; then
                [[ -f $MYRUNTIME/tools/m_redis ]] && source $MYRUNTIME/tools/m_redis || echo "ERROR: m_redis does not exists!"
                custom_title "redis-cli -h $host -p $port"
                echo ""
                custom_title "Result:"
                echo ""
                redis-cli -h $host -p $port
            elif [ "$myservice" = "mongo" ]; then
                custom_title "mongo"
                echo ""
                custom_title "Result:"
                echo ""
                mongo
            elif [ "$myservice" = "memcached" ]; then
                [[ -f $MYRUNTIME/tools/m_memcached ]] && source $MYRUNTIME/tools/m_memcached || echo "ERROR: m_memcached does not exists!"
                custom_title "telnet $host $port"
                echo ""
                custom_title "Result:"
                echo ""
                telnet $host $port
            fi
            ;;
        *)
            if [ "$myservice" = "list" ]; then
                custom_title "Command: brew services list"
                custom_title "Result:"
                echo ""
                echo "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚" | lolcat -f
                for service in $(brew services list | awk '{print $1}' | grep -v 'Name'); do
                    echo "â”‚    $service  " | lolcat -f
                done
                echo "â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n" | lolcat -f
            else
                custom_title "Command: brew services $myoption $myservice"
                custom_title "Result:"
                echo ""
                echo "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" | lolcat -f
                echo "â”‚    $(brew services $myoption $myservice)"
                echo "â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" | lolcat -f
            fi
            ;;
        esac
        
    fi
}
alias bsm="brew_services_manage"                                                    # Desc: alias: bsm: brew_services_manageå‘½ä»¤çš„åˆ«åï¼Œbrew servicesæœåŠ¡å‘½ä»¤ç®¡ç†å™¨