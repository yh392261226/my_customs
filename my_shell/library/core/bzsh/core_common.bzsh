Color_off='\033[0m'       # Text Reset

# terminal color template {{{
# Regular Colors
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
Yellow='\033[0;33m'       # Yellow
Blue='\033[0;34m'         # Blue
Purple='\033[0;35m'       # Purple
Cyan='\033[0;36m'         # Cyan
White='\033[0;37m'        # White

# Bold
BBlack='\033[1;30m'       # Black
BRed='\033[1;31m'         # Red
BGreen='\033[1;32m'       # Green
BYellow='\033[1;33m'      # Yellow
BBlue='\033[1;34m'        # Blue
BPurple='\033[1;35m'      # Purple
BCyan='\033[1;36m'        # Cyan
BWhite='\033[1;37m'       # White

# Underline
UBlack='\033[4;30m'       # Black
URed='\033[4;31m'         # Red
UGreen='\033[4;32m'       # Green
UYellow='\033[4;33m'      # Yellow
UBlue='\033[4;34m'        # Blue
UPurple='\033[4;35m'      # Purple
UCyan='\033[4;36m'        # Cyan
UWhite='\033[4;37m'       # White

# Background
On_Black='\033[40m'       # Black
On_Red='\033[41m'         # Red
On_Green='\033[42m'       # Green
On_Yellow='\033[43m'      # Yellow
On_Blue='\033[44m'        # Blue
On_Purple='\033[45m'      # Purple
On_Cyan='\033[46m'        # Cyan
On_White='\033[47m'       # White

# High Intensity
IBlack='\033[0;90m'       # Black
IRed='\033[0;91m'         # Red
IGreen='\033[0;92m'       # Green
IYellow='\033[0;93m'      # Yellow
IBlue='\033[0;94m'        # Blue
IPurple='\033[0;95m'      # Purple
ICyan='\033[0;96m'        # Cyan
IWhite='\033[0;97m'       # White

# Bold High Intensity
BIBlack='\033[1;90m'      # Black
BIRed='\033[1;91m'        # Red
BIGreen='\033[1;92m'      # Green
BIYellow='\033[1;93m'     # Yellow
BIBlue='\033[1;94m'       # Blue
BIPurple='\033[1;95m'     # Purple
BICyan='\033[1;96m'       # Cyan
BIWhite='\033[1;97m'      # White

# High Intensity backgrounds
On_IBlack='\033[0;100m'   # Black
On_IRed='\033[0;101m'     # Red
On_IGreen='\033[0;102m'   # Green
On_IYellow='\033[0;103m'  # Yellow
On_IBlue='\033[0;104m'    # Blue
On_IPurple='\033[0;105m'  # Purple
On_ICyan='\033[0;106m'    # Cyan
On_IWhite='\033[0;107m'   # White

function msg() {
    printf '%b\n' "$1" >&2
}

function success() {
    msg "${Green}[✔]${Color_off} ${1}${2}"
    return 0
}

function info() {
    msg "${Blue}[➭]${Color_off} ${1}${2}"
    return 0
}

function error() {
    msg "${Red}[✘]${Color_off} ${1}${2}"
    return 1
}

function warn () {
    msg "${Yellow}[⚠]${Color_off} ${1}${2}"
}

function echo_with_color () {
    printf '%b\n' "$1$2$Color_off" >&2
}

function ifHasCommand() {
    if ! command -v $1 >/dev/null 2>&1; then
        echo "0"
    else
        echo "1"
    fi
}

function gotoPath() {
    local gotopath=$1
    if [ "$nowterm" = "iTerm" ]; then
        osascript -e "tell application \"iTerm.app\"
            tell current window
                tell current session
                    write text \"cd "${gotopath}"\"
                end tell
            end tell
        end tell"
    elif [ "$nowterm" = "Terminal" ]; then
        osascript -e "tell application \"Terminal\"
        activate
        do script \"cd ${gotopath}\" in window 1
        end tell"
    fi
}

# 检测 gum 是否安装
[[ "1" = "$(ifHasCommand gum)" ]] && USE_GUM=true || USE_GUM=false

# 通用输入函数
function user_input() {
    local prompt="$1"
    local default_value="$2"
    local secret="$3"
    
    if $USE_GUM; then
        if [ "$secret" = "secret" ]; then
            gum input --password --prompt "$prompt" --placeholder "$default_value"
        else
            gum input --prompt "$prompt" --placeholder "$default_value"
        fi
    else
        if [ "$secret" = "secret" ]; then
            read -rsp "$prompt" value
            echo
        else
            read -rp "$prompt" value
        fi
        echo "${value:-$default_value}"
    fi
}

# 通用等待按键函数 (兼容 macOS bash)
function wait_for_key() {
    if $USE_GUM; then
        gum spin --spinner dot --title "按任意键继续..." -- sleep 0.1
    else
        echo -n "按任意键继续..."
        IFS= read -r -n1 -s
        echo
    fi
}

# 确认对话框函数
function confirm_action() {
    local message="$1"
    
    if $USE_GUM; then
        gum confirm "$message" && return 0
        return 1
    else
        read -rp "$message (y/n): " confirm
        [[ "$confirm" =~ ^[Yy]$ ]]
    fi
}

# 多选函数
function multi_select() {
    local prompt="$1"
    shift
    local options=("$@")
    
    if $USE_GUM; then
        gum choose --no-limit --cursor-prefix "○ " --selected-prefix "◉ " --unselected-prefix "○ " --cursor.foreground 212 --item.foreground 99 --selected.foreground 212 --prompt "$prompt" "${options[@]}"
    else
        echo "$prompt"
        PS3="请选择 (空格选中/取消, 回车确认): "
        select item in "${options[@]}"; do
            if [ -n "$item" ]; then
                echo "$item"
            fi
        done
    fi
}

# 利用gum style输出带有边框和颜色的header
function custom_gum_header() {
    local text="$1"
    echo ""
    gum style --border rounded --border-foreground "#3f633fff" --align center --padding "1 4" --width 98 "$text"
    echo ""
}

# 利用gum spin输出显示一会再隐藏的header
function custom_gum_hidden_header() {
    local text="$1"
    gum spin --title "$(gum style --foreground '#c3573cff' \"$text\")" -- sleep 1
    echo ""
}

# 利用gum spin输出显示一会再隐藏的header
function custom_gum_show2hide_header() {
    local text="$1"
    local duration=${2:-0.5}
    gum spin --title "$(echo "" && gum style --bold --border rounded --border-foreground "#3f633fff" --align center --padding "2 4" --width 98 \"$text\")" -- sleep $duration
    gum style --border rounded --border-foreground "#3f633fff" --align center --width 98 "$text"
    echo ""
}