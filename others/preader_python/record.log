
requirements.txt
----------------------------------------
pyttsx3
chardet
ebooklib
beautifulsoup4
cjkwrap

./bookshelf.py
----------------------------------------
import os
from db import DBManager
from utils import build_pages_from_file
from epub_utils import parse_epub, get_epub_metadata
from lang import get_text
import time

class Bookshelf:
    def __init__(self, lang="zh"):
        self.db = DBManager()
        self.lang = lang
        self.books = self.load_books()

    def load_books(self):
        books = self.db.get_books()
        result = []
        for id_, path, title, author, book_type, old_tags in books:  # æ³¨æ„è¿™é‡Œæ”¹ä¸ºold_tags
            exists = os.path.exists(path)
            # è·å–ä¹¦ç±çš„æ ‡ç­¾åˆ—è¡¨ - ä»æ•°æ®åº“å®æ—¶è·å–
            book_tags = self.db.get_book_tags(id_)
            tag_names = [tag[1] for tag in book_tags]  # è·å–æ ‡ç­¾åç§°åˆ—è¡¨
            
            result.append({
                "id": id_,
                "path": path,
                "title": title,
                "author": author,
                "type": book_type,
                "tags": tag_names,  # ä½¿ç”¨å®æ—¶è·å–çš„æ ‡ç­¾åˆ—è¡¨
                "exists": exists
            })
        # æŒ‰ç…§æ ‡é¢˜å‡åºæ’åº
        result.sort(key=lambda x: x["title"].lower())
        return result

    # æ·»åŠ æ ‡ç­¾ç›¸å…³æ–¹æ³•
    def get_all_tags(self):
        """è·å–æ‰€æœ‰æ ‡ç­¾"""
        tags = self.db.get_all_tags()
        return [tag[1] for tag in tags]

    def filter_books_by_tag(self, tag_name):
        """æŒ‰æ ‡ç­¾è¿‡æ»¤ä¹¦ç± - ä¿®å¤ç­›é€‰é€»è¾‘"""
        if not tag_name:  # å¦‚æœæ ‡ç­¾ä¸ºç©ºï¼Œè¿”å›æ‰€æœ‰ä¹¦ç±
            return self.books
            
        return [book for book in self.books if tag_name in book["tags"]]

    def update_book_metadata(self, book_id, title, author, tags):
        """æ›´æ–°ä¹¦ç±å…ƒæ•°æ®"""
        self.db.update_book_metadata(book_id, title, author, tags)
        # é‡æ–°åŠ è½½ä¹¦ç±åˆ—è¡¨
        self.books = self.load_books()

    def batch_update_tags(self, book_ids, action, tag_name):
        """æ‰¹é‡æ›´æ–°æ ‡ç­¾ - ç¡®ä¿æ•°æ®æ­£ç¡®æ›´æ–°"""
        for book_id in book_ids:
            if action == "add":
                tag_id = self.db.add_tag(tag_name)
                self.db.add_book_tag(book_id, tag_id)
            elif action == "remove":
                # é¦–å…ˆè·å–æ ‡ç­¾ID
                all_tags = self.db.get_all_tags()
                tag_id = None
                for tag in all_tags:
                    if tag[1] == tag_name:
                        tag_id = tag[0]
                        break
                if tag_id:
                    self.db.remove_book_tag(book_id, tag_id)
        
        # é‡æ–°åŠ è½½ä¹¦ç±åˆ—è¡¨ - ç¡®ä¿æ•°æ®æ­£ç¡®æ›´æ–°
        self.books = self.load_books()
        return True

    def check_books_existence(self):
        """æ£€æŸ¥æ‰€æœ‰ä¹¦ç±æ–‡ä»¶æ˜¯å¦å­˜åœ¨"""
        for book in self.books:
            book["exists"] = os.path.exists(book["path"])
        return self.books

    def update_book_path(self, book_id, new_path):
        """æ›´æ–°ä¹¦ç±è·¯å¾„"""
        if not os.path.exists(new_path):
            return False
            
        # æ›´æ–°æ•°æ®åº“
        self.db.update_book_path(book_id, new_path)
        
        # æ›´æ–°å†…å­˜ä¸­çš„ä¹¦ç±åˆ—è¡¨
        for book in self.books:
            if book["id"] == book_id:
                book["path"] = new_path
                book["exists"] = True
                break
                
        return True

    def delete_book(self, book_id):
        """ä»ä¹¦æ¶åˆ é™¤ä¹¦ç±"""
        # ä»æ•°æ®åº“åˆ é™¤
        self.db.delete_book(book_id)
        
        # ä»å†…å­˜ä¸­çš„ä¹¦ç±åˆ—è¡¨åˆ é™¤
        self.books = [book for book in self.books if book["id"] != book_id]
        
    def delete_books(self, book_ids):
        """æ‰¹é‡åˆ é™¤ä¹¦ç±"""
        for book_id in book_ids:
            self.db.delete_book(book_id)
        
        # ä»å†…å­˜ä¸­çš„ä¹¦ç±åˆ—è¡¨åˆ é™¤
        self.books = [book for book in self.books if book["id"] not in book_ids]

    def add_book(self, file_path, tags="", width=80, height=25, line_spacing=1):
        ext = os.path.splitext(file_path)[-1].lower()
        if not os.path.exists(file_path):
            return None
            
        # ç®€å•çš„åŠ è½½æç¤º
        print(f"{get_text('loading_books', self.lang)}...")
        if ext == ".epub":
            print(f"{get_text('parsing_epub_data', self.lang)}...")
            title, author = get_epub_metadata(file_path)
            print(f"{get_text('save_to_db', self.lang)}...")
            self.db.add_book(file_path, title or os.path.basename(file_path), author, "epub", tags)
        else:
            print(f"{get_text('save_to_db', self.lang)}...")
            self.db.add_book(file_path, os.path.basename(file_path), "", "txt", tags)
            
        self.books = self.load_books()

    def add_dir(self, dir_path, tags="", width=80, height=25, line_spacing=1):
        if not os.path.isdir(dir_path):
            return
            
        # è·å–ç›®å½•ä¸­æ‰€æœ‰æ”¯æŒçš„ä¹¦ç±æ–‡ä»¶
        files = []
        for fname in os.listdir(dir_path):
            fpath = os.path.join(dir_path, fname)
            if os.path.isfile(fpath) and fname.lower().endswith(('.txt', '.epub', '.md')):
                files.append(fpath)
                
        # ç®€å•çš„åŠ è½½æç¤º
        print(f"{get_text('total_add_books', self.lang).format(books=len(files))}...")
        for i, fpath in enumerate(files):
            print(f"{get_text('parsing_books', self.lang).format(books=f'{i+1}/{len(files)}')}: {os.path.basename(fpath)}")
            self.add_book(fpath, tags=tags, width=width, height=height, line_spacing=line_spacing)

    def get_book_by_id(self, book_id):
        for b in self.books:
            if b["id"] == book_id:
                return b
        return None

    def search_books(self, keyword):
        keyword = keyword.strip().lower()
        result = [book for book in self.books if keyword in book["title"].lower()]
        # æœç´¢ç»“æœä¹ŸæŒ‰ç…§æ ‡é¢˜å‡åºæ’åº
        result.sort(key=lambda x: x["title"].lower())
        return result
    
    def delete_book(self, book_id):
        self.db.delete_book(book_id)
        self.books = self.load_books()

    def get_books_by_ids(self, book_ids):
        """æ ¹æ®IDåˆ—è¡¨è·å–ä¹¦ç±ä¿¡æ¯"""
        return [book for book in self.books if book["id"] in book_ids]
    
    def get_all_books(self):
        """è·å–æ‰€æœ‰ä¹¦ç±"""
        return self.books
    
    def delete_tag(self, tag_name):
        """åˆ é™¤æ ‡ç­¾"""
        # è·å–æ ‡ç­¾ID
        tag_id = self.db.get_tag_id(tag_name)
        if tag_id:
            return self.db.delete_tag(tag_id)
        return False

./db.py
----------------------------------------
import os
import sqlite3

def get_db_path():
    home = os.environ.get("HOME")
    config_dir = os.path.join(home, ".config", "preader")
    os.makedirs(config_dir, exist_ok=True)
    return os.path.join(config_dir, "novel_reader.db")

class DBManager:
    def __init__(self):
        self.db_path = get_db_path()
        self.conn = sqlite3.connect(self.db_path)
        self._init_db()

    def _init_db(self):
        c = self.conn.cursor()
        c.execute("""CREATE TABLE IF NOT EXISTS books (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            path TEXT UNIQUE,
            title TEXT,
            author TEXT,
            type TEXT,
            tags TEXT
        )""")
        # æ·»åŠ æ ‡ç­¾è¡¨
        c.execute("""CREATE TABLE IF NOT EXISTS tags (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE
        )""")
        c.execute("""CREATE TABLE IF NOT EXISTS book_tags (
            book_id INTEGER,
            tag_id INTEGER,
            PRIMARY KEY(book_id, tag_id),
            FOREIGN KEY(book_id) REFERENCES books(id),
            FOREIGN KEY(tag_id) REFERENCES tags(id)
        )""")
        c.execute("""CREATE TABLE IF NOT EXISTS progress (
            book_id INTEGER,
            page_idx INTEGER,
            PRIMARY KEY(book_id)
        )""")
        c.execute("""CREATE TABLE IF NOT EXISTS bookmarks (
            book_id INTEGER,
            page_idx INTEGER,
            comment TEXT
        )""")
        c.execute("""CREATE TABLE IF NOT EXISTS stats (
            book_id INTEGER,
            date TEXT,
            seconds INTEGER,
            PRIMARY KEY(book_id, date)
        )""")
        self.conn.commit()
    # æ·»åŠ æ ‡ç­¾ç›¸å…³æ–¹æ³•
    def get_all_tags(self):
        """è·å–æ‰€æœ‰æ ‡ç­¾"""
        c = self.conn.cursor()
        c.execute("SELECT id, name FROM tags ORDER BY name")
        return c.fetchall()

    def add_tag(self, tag_name):
        """æ·»åŠ æ ‡ç­¾"""
        c = self.conn.cursor()
        c.execute("INSERT OR IGNORE INTO tags (name) VALUES (?)", (tag_name,))
        self.conn.commit()
        return c.lastrowid
    
    def get_book_tags(self, book_id):
        """è·å–ä¹¦ç±çš„æ ‡ç­¾"""
        c = self.conn.cursor()
        c.execute("""SELECT t.id, t.name FROM tags t 
                     JOIN book_tags bt ON t.id = bt.tag_id 
                     WHERE bt.book_id = ?""", (book_id,))
        return c.fetchall()

    def add_book_tag(self, book_id, tag_id):
        """ä¸ºä¹¦ç±æ·»åŠ æ ‡ç­¾"""
        c = self.conn.cursor()
        c.execute("INSERT OR IGNORE INTO book_tags (book_id, tag_id) VALUES (?, ?)", (book_id, tag_id))
        self.conn.commit()

    def remove_book_tag(self, book_id, tag_id):
        """ç§»é™¤ä¹¦ç±çš„æ ‡ç­¾"""
        c = self.conn.cursor()
        c.execute("DELETE FROM book_tags WHERE book_id=? AND tag_id=?", (book_id, tag_id))
        self.conn.commit()
    
    def update_book_metadata(self, book_id, title, author, tags):
        """æ›´æ–°ä¹¦ç±å…ƒæ•°æ®ï¼ˆæ ‡é¢˜ã€ä½œè€…ã€æ ‡ç­¾ï¼‰"""
        c = self.conn.cursor()
        # æ›´æ–°æ ‡é¢˜å’Œä½œè€…
        c.execute("UPDATE books SET title=?, author=? WHERE id=?", (title, author, book_id))
        
        # æ¸…ç©ºç°æœ‰æ ‡ç­¾
        c.execute("DELETE FROM book_tags WHERE book_id=?", (book_id,))
        
        # æ·»åŠ æ–°æ ‡ç­¾
        if tags:
            tag_list = [tag.strip() for tag in tags.split(',') if tag.strip()]
            for tag_name in tag_list:
                # ç¡®ä¿æ ‡ç­¾å­˜åœ¨
                tag_id = self.add_tag(tag_name)
                # å…³è”æ ‡ç­¾å’Œä¹¦ç±
                self.add_book_tag(book_id, tag_id)
        
        self.conn.commit()

    def add_book(self, path, title, author, book_type, tags):
        c = self.conn.cursor()
        c.execute("INSERT OR IGNORE INTO books (path, title, author, type, tags) VALUES (?, ?, ?, ?, ?)",
                  (path, title, author, book_type, tags))
        book_id = c.lastrowid
        
        # å¤„ç†æ ‡ç­¾
        if tags:
            tag_list = [tag.strip() for tag in tags.split(',') if tag.strip()]
            for tag_name in tag_list:
                tag_id = self.add_tag(tag_name)
                self.add_book_tag(book_id, tag_id)
        
        self.conn.commit()
        return book_id

    def get_books(self):
        c = self.conn.cursor()
        c.execute("SELECT id, path, title, author, type, tags FROM books ORDER BY id DESC")
        return c.fetchall()

    def save_progress(self, book_id, page_idx):
        c = self.conn.cursor()
        c.execute("INSERT OR REPLACE INTO progress (book_id, page_idx) VALUES (?, ?)", (book_id, page_idx))
        self.conn.commit()

    def get_progress(self, book_id):
        c = self.conn.cursor()
        c.execute("SELECT page_idx FROM progress WHERE book_id=?", (book_id,))
        r = c.fetchone()
        return r[0] if r else 0

    def add_bookmark(self, book_id, page_idx, comment):
        c = self.conn.cursor()
        c.execute("INSERT INTO bookmarks (book_id, page_idx, comment) VALUES (?, ?, ?)", (book_id, page_idx, comment))
        self.conn.commit()

    def get_bookmarks(self, book_id):
        c = self.conn.cursor()
        c.execute("SELECT page_idx, comment FROM bookmarks WHERE book_id=? ORDER BY page_idx", (book_id,))
        return c.fetchall()

    def record_stat(self, book_id, date, seconds):
        c = self.conn.cursor()
        c.execute("SELECT seconds FROM stats WHERE book_id=? AND date=?", (book_id, date))
        r = c.fetchone()
        if r:
            c.execute("UPDATE stats SET seconds=seconds+? WHERE book_id=? AND date=?", (seconds, book_id, date))
        else:
            c.execute("INSERT INTO stats (book_id, date, seconds) VALUES (?, ?, ?)", (book_id, date, seconds))
        self.conn.commit()

    def get_stats(self, book_id):
        c = self.conn.cursor()
        c.execute("SELECT date, seconds FROM stats WHERE book_id=? ORDER BY date", (book_id,))
        return c.fetchall()

    def delete_book(self, book_id):
        c = self.conn.cursor()
        c.execute("DELETE FROM books WHERE id=?", (book_id,))
        c.execute("DELETE FROM progress WHERE book_id=?", (book_id,))
        c.execute("DELETE FROM bookmarks WHERE book_id=?", (book_id,))
        c.execute("DELETE FROM stats WHERE book_id=?", (book_id,))
        self.conn.commit()

    def update_book_path(self, book_id, new_path):
        """æ›´æ–°ä¹¦ç±è·¯å¾„"""
        c = self.conn.cursor()
        c.execute("UPDATE books SET path=? WHERE id=?", (new_path, book_id))
        self.conn.commit()

    def delete_book(self, book_id):
        """åˆ é™¤ä¹¦ç±åŠå…¶æ‰€æœ‰ç›¸å…³æ•°æ®"""
        c = self.conn.cursor()
        # åˆ é™¤ä¹¦ç±
        c.execute("DELETE FROM books WHERE id=?", (book_id,))
        # åˆ é™¤é˜…è¯»è¿›åº¦
        c.execute("DELETE FROM progress WHERE book_id=?", (book_id,))
        # åˆ é™¤ä¹¦ç­¾
        c.execute("DELETE FROM bookmarks WHERE book_id=?", (book_id,))
        # åˆ é™¤é˜…è¯»ç»Ÿè®¡
        c.execute("DELETE FROM stats WHERE book_id=?", (book_id,))
        self.conn.commit()

    def delete_tag(self, tag_id):
        """åˆ é™¤æ ‡ç­¾åŠå…¶æ‰€æœ‰å…³è”"""
        c = self.conn.cursor()
        # å…ˆåˆ é™¤ä¹¦ç±æ ‡ç­¾å…³è”
        c.execute("DELETE FROM book_tags WHERE tag_id=?", (tag_id,))
        # å†åˆ é™¤æ ‡ç­¾æœ¬èº«
        c.execute("DELETE FROM tags WHERE id=?", (tag_id,))
        self.conn.commit()
        return True
    
    def get_tag_id(self, tag_name):
        """æ ¹æ®æ ‡ç­¾åç§°è·å–æ ‡ç­¾ID"""
        c = self.conn.cursor()
        c.execute("SELECT id FROM tags WHERE name=?", (tag_name,))
        result = c.fetchone()
        return result[0] if result else None

./epub_utils.py
----------------------------------------
from ebooklib import epub
from bs4 import BeautifulSoup
from utils import build_pages_from_text
from lang import get_text

def parse_epub(file_path, width, height, line_spacing, lang="zh"):
    book = epub.read_epub(file_path)
    
    chapters = []
    items = list(book.get_items())
    
    for item in items:
        if item.get_type() == epub.ITEM_DOCUMENT:
            soup = BeautifulSoup(item.get_content(), "html.parser")
            title = soup.title.string if soup.title else ""
            text = soup.get_text()
            
            # ä½¿ç”¨ç»Ÿä¸€çš„æ–‡æœ¬åˆ†é¡µå‡½æ•°
            pages = build_pages_from_text(text, width, height, line_spacing, lang=lang)
            chapters.append({"title": title, "pages": pages})
            
    return chapters

def get_epub_metadata(file_path):
    book = epub.read_epub(file_path)
    title = book.get_metadata('DC', 'title')[0][0] if book.get_metadata('DC', 'title') else ""
    author = book.get_metadata('DC', 'creator')[0][0] if book.get_metadata('DC', 'creator') else ""
    return title, author

./lang.py
----------------------------------------
LANGS = {
    "zh": {
        "bookshelf": "ä¹¦æ¶",
        "add_book": "æ·»åŠ å°è¯´",
        "add_dir": "æ·»åŠ ç›®å½•",
        "progress": "è¿›åº¦",
        "bookmark": "ä¹¦ç­¾",
        "help": "å¸®åŠ©",
        "exit": "é€€å‡º",
        "setting": "è®¾ç½®",
        "search": "æœç´¢",
        "stats": "é˜…è¯»ç»Ÿè®¡",
        "stats_all": "å…¨éƒ¨ä¹¦ç±é˜…è¯»ç»Ÿè®¡",
        "stats_time": "ç´¯è®¡é˜…è¯»æ—¶é—´",
        "stats_days": "é˜…è¯»å¤©æ•°",
        "stats_daily": "æ¯æ—¥ç»Ÿè®¡",
        "read": "æœ—è¯»",
        "chapter": "ç« èŠ‚",
        "theme": "ä¸»é¢˜",
        "language": "è¯­è¨€",
        "current_page": "å½“å‰é¡µ",
        "auto_page": "è‡ªåŠ¨ç¿»é¡µ",
        "jump_chapter": "è·³è½¬ç« èŠ‚",
        "author": "ä½œè€…",
        "input_path": "è¾“å…¥æ–‡ä»¶è·¯å¾„ï¼š",
        "input_dir": "è¾“å…¥ç›®å½•è·¯å¾„ï¼š",
        "input_search": "è¾“å…¥æœç´¢å…³é”®è¯ï¼š",
        "input_comment": "è¾“å…¥ä¹¦ç­¾å¤‡æ³¨ï¼š",
        "input_theme": "ä¸»é¢˜ (dark/light/eye)ï¼š",
        "input_lang": "è¯­è¨€ (zh/en)ï¼š",
        "input_font_color": "å­—ä½“é¢œè‰²(black/red/green/yellow/blue/magenta/cyan/white)ï¼š",
        "input_bg_color": "èƒŒæ™¯é¢œè‰²(black/red/green/yellow/blue/magenta/cyan/white)ï¼š",
        "input_border_style": "è¾¹æ¡†æ ·å¼(round/double/single/bold/none)ï¼š",
        "input_border_color": "è¾¹æ¡†é¢œè‰²(black/red/green/yellow/blue/magenta/cyan/white)ï¼š",
        "input_jump_page": "è¾“å…¥é¡µç å¹¶å›è½¦è·³è½¬ï¼š",
        "input_jump_page_quit": "è¾“å…¥é¡µç å¹¶å›è½¦è·³è½¬, qé€€å‡º",
        "bookmark_list": "ä¹¦ç­¾åˆ—è¡¨",
        "input_remind_interval": "é˜…è¯»æé†’é—´éš”(åˆ†é’Ÿ, 0ä¸ºå…³é—­)ï¼š",
        "remind_msg": "æ‚¨å·²é˜…è¯»{minutes}åˆ†é’Ÿäº†ï¼Œä¼‘æ¯ä¸€ä¸‹çœ¼ç›å§ï¼",
        "invalid": "æ— æ•ˆè¾“å…¥",
        "pre_page": "ä¸Šä¸€é¡µ",
        "next_page": "ä¸‹ä¸€é¡µ",
        "delete": "åˆ é™¤",
        "move": "ç§»åŠ¨",
        "select": "é€‰æ‹©",
        "tag": "æ ‡ç­¾",
        "input_no": "è¾“å…¥åºå·",
        "no_unlimited": "åºå·è¶…èŒƒå›´ï¼",
        "wait_for_loading":"è¯·ç¨å€™ï¼Œæ­£åœ¨åŠªåŠ›åŠ è½½",
        "loading": "åŠ è½½ä¸­",
        "novel_reader": "å°è¯´é˜…è¯»å™¨",
        "number": "åºå·",
        "minutes": "åˆ†é’Ÿ",
        "day": "å¤©",
        "back": "è¿”å›",
        "page_no": "ç¬¬{page}é¡µ",
        "book_deletion_title": "åˆ é™¤ä¹¦ç± - ç©ºæ ¼é€‰æ‹©/å–æ¶ˆ, Enterç¡®è®¤åˆ é™¤, qè¿”å›",
        "book_deletion_help": "[â†‘â†“]ç§»åŠ¨ [ç©ºæ ¼]é€‰æ‹©/å–æ¶ˆ [n]ä¸‹ä¸€é¡µ [p]ä¸Šä¸€é¡µ [a]å…¨é€‰ [c]å–æ¶ˆå…¨é€‰ [Enter]åˆ é™¤é€‰ä¸­ [q]è¿”å›",
        "book_deletion_confirm": "ç¡®è®¤åˆ é™¤ {books} æœ¬ä¹¦ç±?",
        "book_deletion_success": "å·²æˆåŠŸåˆ é™¤ {books} æœ¬ä¹¦ç±",
        "reading_progress": "é˜…è¯»è¿›åº¦",
        "empty_file_or_cannot_read": "æ–‡ä»¶ä¸ºç©ºæˆ–æ— æ³•è§£æå†…å®¹",
        "aloud_r2_stop": "æœ—è¯»ä¸­ - æŒ‰råœæ­¢",
        "books": "ä¹¦ç±",
        "unfind_type_new": "æœªæ‰¾åˆ°ï¼Œè¯·è¾“å…¥æ–°è·¯å¾„",
        "update_path_success": "è·¯å¾„æ›´æ–°æˆåŠŸ!",
        "update_path_fail": "è·¯å¾„æ›´æ–°å¤±è´¥!",
        "path_not_exists": "è·¯å¾„æ— æ•ˆæˆ–æ–‡ä»¶ä¸å­˜åœ¨!",
        "terminal_help_text": "æŒ‰ç©ºæ ¼+å›è½¦è¿”å› | â†‘â†“æµè§ˆå†å²å‘½ä»¤",
        "terminal_title": "ç»ˆç«¯æ¨¡å¼",
        "terminal_help_text2": "ä½¿ç”¨ç©ºæ ¼+å›è½¦é€€å‡ºç»ˆç«¯æ¨¡å¼",
        "command_exists_code": "å‘½ä»¤é€€å‡ºä»£ç ",
        "command_time_unlimit": "å‘½ä»¤æ‰§è¡Œè¶…æ—¶",
        "execute_fail": "æ‰§è¡Œé”™è¯¯",
        "terminal_mode_started": "ç»ˆç«¯æ¨¡æ‹Ÿå™¨å·²å¯åŠ¨",
        "file_not_exists": "æ–‡ä»¶ä¸å­˜åœ¨",
        "cannot_load_novel": "æ— æ³•åŠ è½½å°è¯´",
        "empty_directory_or_file": "ç©ºæ–‡ä»¶æˆ–æ–‡ä»¶å†…å®¹ä¸ºç©º",
        "action_document_line": "å¤„ç†æ–‡æœ¬è¡Œ",
        "action_document_file": "å¤„ç†æ–‡æœ¬å†…å®¹",
        "action_pages": "åˆ†é¡µå¤„ç†",
        "reading_from_file": "è¯»å–æ–‡ä»¶å†…å®¹",
        "loading_books": "åŠ è½½ä¹¦ç±ä¸­",
        "parsing_epub_data": "è§£æEPUBå…ƒæ•°æ®",
        "save_to_db": "ä¿å­˜åˆ°æ•°æ®åº“",
        "total_add_books": "æ·»åŠ ç›®å½•ä¸­çš„ä¹¦ç±ï¼Œå…± {books} æœ¬",
        "parsing_books": "å¤„ç†ç¬¬ {books} æœ¬",
        "tag_management": "æ ‡ç­¾ç®¡ç†",
        "edit_book": "ç¼–è¾‘ä¹¦ç±",
        "add_tag": "æ·»åŠ æ ‡ç­¾",
        "remove_tag": "åˆ é™¤æ ‡ç­¾",
        "filter_by_tag": "æŒ‰æ ‡ç­¾ç­›é€‰",
        "batch_edit": "æ‰¹é‡ç¼–è¾‘",
        "edit_title": "ç¼–è¾‘æ ‡é¢˜",
        "edit_author": "ç¼–è¾‘ä½œè€…",
        "edit_tags": "ç¼–è¾‘æ ‡ç­¾",
        "save_changes": "ä¿å­˜æ›´æ”¹",
        "tag_already_exists": "æ ‡ç­¾å·²å­˜åœ¨",
        "tag_added": "æ ‡ç­¾å·²æ·»åŠ ",
        "tag_removed": "æ ‡ç­¾å·²ç§»é™¤",
        "no_tags": "æ— æ ‡ç­¾",
        "tag_mode": "æ ‡ç­¾æ¨¡å¼: ä½¿ç”¨ç©ºæ ¼é€‰æ‹©/å–æ¶ˆæ ‡ç­¾ï¼ŒEnterç¡®è®¤",
        "switch_tag_mode":"åˆ‡æ¢æ ‡ç­¾æ¨¡å¼",
        "confirm":"ç¡®è®¤",
        "multype_tags_edit_books": "æ‰¹é‡æ ‡ç­¾ç¼–è¾‘ ({books}) æœ¬ä¹¦",
        "out_multype_mode": "é€€å‡ºå¤šé€‰æ¨¡å¼",
        "in_multype_mode": "è¿›å…¥å¤šé€‰æ¨¡å¼",
        "space": "ç©ºæ ¼",
        "select_or_unselect": "é€‰æ‹©/å–æ¶ˆ",
        "multype_tags_edit": "æ‰¹é‡ç¼–è¾‘æ ‡ç­¾",
        "select_all": "å…¨é€‰",
        "unselect_all": "å–æ¶ˆå…¨é€‰",
        "multype_mode": "å¤šé€‰æ¨¡å¼",
        "already_selected_books": "å·²é€‰ {books} æœ¬",
    },
    "en": {
        "bookshelf": "Bookshelf",
        "add_book": "Add Book",
        "add_dir": "Add Directory",
        "progress": "Progress",
        "bookmark": "Bookmark",
        "help": "Help",
        "exit": "Exit",
        "setting": "Settings",
        "search": "Search",
        "stats": "Reading Stats",
        "stats_all": "All Books Stats",
        "stats_time": "Total Reading Time",
        "stats_days": "Reading Days",
        "stats_daily": "Daily Stats",
        "read": "Read Aloud",
        "chapter": "Chapter",
        "theme": "Theme",
        "language": "Language",
        "current_page": "Page",
        "auto_page": "Auto Page",
        "jump_chapter": "Jump Chapter",
        "author": "Author",
        "input_path": "Input file path:",
        "input_dir": "Input directory path:",
        "input_search": "Input search keyword:",
        "input_comment": "Input bookmark comment:",
        "input_theme": "Theme (dark/light/eye):",
        "input_lang": "Language (zh/en):",
        "input_font_color": "Font color (black/red/green/yellow/blue/magenta/cyan/white):",
        "input_bg_color": "Background color (black/red/green/yellow/blue/magenta/cyan/white):",
        "input_border_style": "Border style (round/double/single/bold/none):",
        "input_border_color": "Border color (black/red/green/yellow/blue/magenta/cyan/white):",
        "input_jump_page": "Input page number and press Enter to jump:",
        "input_jump_page_quit": "Input page number and press Enter to jump, press q to quit",
        "bookmark_list": "Bookmark List",
        "input_remind_interval": "Reading reminder interval (minutes, 0=off):",
        "remind_msg": "You've been reading for {minutes} minutes, please rest your eyes!",
        "invalid": "Invalid input",
        "pre_page": "Previous",
        "next_page": "Next",
        "delete": "Delete",
        "move": "Move",
        "select": "Select",
        "tag": "Tag",
        "input_no": "Input number",
        "no_unlimited": "The number is out of limitï¼",
        "wait_for_loading":"Please wait for Loading",
        "loading": "Loading",
        "novel_reader": "Novel Reader",
        "number": "NO",
        "minutes": "minites",
        "day": "day",
        "back": "Back",
        "page_no": "page {page}",
        "book_deletion_title": "Book deletion - space to select/unselect, Enter to delete, q to quit",
        "book_deletion_help": "[â†‘â†“] Move [space] Select/Unselect [n] Next page [p] Previous page [a] Select all [c] Unselect all [Enter] Delete [q] Back",
        "book_deletion_confirm": "Confirm to delete {books} books ?",
        "book_deletion_success": "delete {books} books success",
        "reading_progress": "reading progress",
        "empty_file_or_cannot_read": "empty file or can not read",
        "aloud_r2_stop": "Read aloud - Press r to stop",
        "books": "Books",
        "unfind_type_new": "Can not findï¼ŒPlease type new path",
        "update_path_success": "Update path successs!",
        "update_path_fail": "Update path failed!",
        "path_not_exists": "Path invalid or file does not exists!",
        "terminal_help_text": "Press Space + Enter to back | â†‘â†“ Show history command",
        "terminal_title": "Terminal Mode",
        "terminal_help_text2": "Press Space + Enter to quit",
        "command_exists_code": "Command exists code",
        "command_time_unlimit": "Command timeout",
        "execute_fail": "Execution Error",
        "terminal_mode_started": "Terminal mode started",
        "file_not_exists": "File does not exists",
        "cannot_load_novel": "Load novel failed",
        "empty_directory_or_file": "Empty directory or file",
        "action_document_line": "Dealing with document lines",
        "action_document_file": "Dealing with document files",
        "action_pages": "Dealing with pages",
        "reading_from_file": "Reading from file",
        "loading_books": "Loadding books",
        "parsing_epub_data": "Parsing EPUB metadata",
        "save_to_db": "Save to database",
        "total_add_books": "Total books in path is {books}",
        "parsing_books": "Parsing books {books}",
        "tag_mode": "Tag mode: Press space to select/unselectï¼ŒEnter to confirm",
        "tag_management": "Tag Management",
        "edit_book": "Edit Book",
        "add_tag": "Add Tag",
        "remove_tag": "Remove Tag",
        "filter_by_tag": "Filter by Tag",
        "batch_edit": "Batch Edit",
        "edit_title": "Edit Title",
        "edit_author": "Edit Author",
        "edit_tags": "Edit Tags",
        "save_changes": "Save Changes",
        "tag_already_exists": "Tag already exists",
        "tag_added": "Tag added",
        "tag_removed": "Tag removed",
        "no_tags": "No tags",
        "switch_tag_mode":"Switch tag mode",
        "confirm":"Confirm",
        "multype_tags_edit_books": "Multype tags edit books ({books})",
        "out_multype_mode": "Multype mode exists",
        "in_multype_mode": "Into multype mode",
        "space": "Space",
        "select_or_unselect": "Select/Unselect",
        "multype_tags_edit": "Multype edit tags",
        "select_all": "Select All",
        "unselect_all": "Unselect All",
        "multype_mode": "Multype Mode",
        "already_selected_books": "Selected {books}",
    }
}

def get_text(key, lang="zh"):
    return LANGS.get(lang, LANGS["zh"]).get(key, key)

./main.py
----------------------------------------
import curses
import sys
import os
import signal  # æ·»åŠ signalå¯¼å…¥
from bookshelf import Bookshelf
from settings import Settings
from lang import get_text
from reader import NovelReader

def signal_handler(sig, frame):
    # æ¸…ç†å·¥ä½œ
    sys.exit(0)

def main(stdscr):
    curses.curs_set(0)
    # è®¾ç½®ä¿¡å·å¤„ç†
    signal.signal(signal.SIGINT, signal_handler)
    settings = Settings()
    bookshelf = Bookshelf(settings["lang"])
    reader = NovelReader(stdscr, bookshelf, settings)

    # æ”¯æŒå‘½ä»¤è¡Œç›´æ¥æ‰“å¼€æ–‡ä»¶
    if len(sys.argv) > 1:
        novel_path = sys.argv[1]
        if not os.path.isfile(novel_path):
            stdscr.addstr(0, 0, f"{get_text('file_not_exists', settings['lang'])}: {novel_path}")
            stdscr.refresh()
            stdscr.getch()
            return
        bookshelf.add_book(novel_path, width=settings["width"], height=settings["height"], line_spacing=settings["line_spacing"])
        if bookshelf.books:
            reader.load_book(bookshelf.books[-1])
        else:
            stdscr.addstr(0, 0, f"{get_text('cannot_load_novel', settings['lang'])}: {novel_path}")
            stdscr.refresh()
            stdscr.getch()
            return
    # è¿›å…¥ä¸»å¾ªç¯
    reader.run()

if __name__ == '__main__':
    curses.wrapper(main)

./reader.py
----------------------------------------
import subprocess
import shlex
import tempfile
import os
import curses
import time
import pyttsx3
import threading
from utils import build_pages_from_file
from db import DBManager
from stats import StatsManager
from ui_theme import init_colors, BORDER_CHARS, color_pair_idx
from lang import get_text
from epub_utils import parse_epub

KEYS_HELP = [
    "â†/â†’/PgUp/PgDn/j/k ç¿»é¡µ",
    "a è‡ªåŠ¨ç¿»é¡µ",
    "b æ·»åŠ ä¹¦ç­¾",
    "B ä¹¦ç­¾åˆ—è¡¨",
    "g è·³é¡µ",
    "m ä¹¦æ¶",
    "s è®¾ç½®",
    "r æœ—è¯»/åœæ­¢",
    "/ æœç´¢",
    "? å¸®åŠ©",
    "q é€€å‡º",
    "t é˜…è¯»ç»Ÿè®¡",
    "T å…¨éƒ¨ç»Ÿè®¡",
    "x åˆ é™¤ä¹¦ç±",
    "ç©ºæ ¼ è€æ¿é”®"
]

def input_box(stdscr, prompt, maxlen=50, color_pair=2, y=None, x=None):
    """ç¾åŒ–è¾“å…¥æ¡†ï¼Œå±…ä¸­æ˜¾ç¤º"""
    max_y, max_x = stdscr.getmaxyx()
    if y is None:
        y = max_y // 2 - 1
    if x is None:
        x = max_x // 2 - len(prompt) // 2 - 8
    box_width = max(len(prompt) + maxlen + 8, 30)
    stdscr.attron(curses.color_pair(color_pair) | curses.A_BOLD)
    # è¾¹æ¡†
    stdscr.addstr(y, x, "â•­" + "â”€" * (box_width-2) + "â•®")
    stdscr.addstr(y+1, x, "â”‚" + " " * (box_width-2) + "â”‚")
    stdscr.addstr(y+2, x, "â•°" + "â”€" * (box_width-2) + "â•¯")
    # æç¤º
    stdscr.addstr(y+1, x+2, prompt)
    stdscr.attroff(curses.color_pair(color_pair) | curses.A_BOLD)
    stdscr.refresh()
    
    # ä½¿ç”¨æ›´å®‰å…¨çš„æ–¹æ³•å¤„ç†è¾“å…¥
    curses.echo()
    try:
        # ä½¿ç”¨getsträ½†æ•è·å¯èƒ½çš„è§£ç é”™è¯¯
        val_bytes = stdscr.getstr(y+1, x+2+len(prompt), maxlen)
        
        # å°è¯•UTF-8è§£ç ï¼Œå¦‚æœå¤±è´¥åˆ™ä½¿ç”¨æ›¿ä»£æ–¹æ³•
        try:
            val = val_bytes.decode('utf-8').strip()
        except UnicodeDecodeError:
            # å¦‚æœUTF-8è§£ç å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨latin-1ç¼–ç 
            val = val_bytes.decode('latin-1').strip()
    except Exception as e:
        # å¦‚æœå‡ºç°ä»»ä½•å¼‚å¸¸ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²
        val = ""
    
    curses.noecho()
    return val

class NovelReader:
    def __init__(self, stdscr, bookshelf, settings):
        self.stdscr = stdscr
        self.bookshelf = bookshelf
        self.settings = settings
        self.db = DBManager()
        self.stats = StatsManager()
        self.engine = pyttsx3.init()
        self.current_book = None
        self.current_pages = []
        self.current_page_idx = 0
        self.start_time = time.time()
        self.auto_page = False
        self.search_keyword = ""
        self.highlight_lines = set()
        self.running = True
        self.lang = self.settings["lang"]
        self.last_remind_time = time.time()
        self.remind_minutes = self.settings["remind_interval"]
        self.is_reading = False  # æ·»åŠ æœ—è¯»çŠ¶æ€æ ‡å¿—
        self.reading_thread = None  # æ·»åŠ æœ—è¯»çº¿ç¨‹
        self.boss_mode = False  # è€æ¿é”®æ¨¡å¼æ ‡å¿—
        self.terminal_history = []  # ç»ˆç«¯å‘½ä»¤å†å²
        self.terminal_position = 0  # ç»ˆç«¯å†å²ä½ç½®
        self.selected_tags = set() # å­˜å‚¨é€‰ä¸­çš„æ ‡ç­¾
        init_colors(theme=self.settings["theme"], settings=self.settings)

    def get_safe_height(self):
        """è®¡ç®—å®‰å…¨çš„æ˜¾ç¤ºé«˜åº¦ï¼Œè€ƒè™‘è¾¹æ¡†å’Œè¾¹è·"""
        max_y, _ = self.stdscr.getmaxyx()
        margin = self.settings["margin"]
        # é¢„ç•™é¡¶éƒ¨/åº•éƒ¨/çŠ¶æ€æ ç©ºé—´ï¼ˆ9è¡Œï¼‰
        return max(1, min(self.settings["height"], max_y - margin - 9))

    def show_loading_screen(self, message, progress=None):
        """æ˜¾ç¤ºç¾è§‚çš„åŠ è½½å±å¹•ï¼Œæ”¯æŒè¿›åº¦æ˜¾ç¤º"""
        self.stdscr.clear()
        max_y, max_x = self.stdscr.getmaxyx()
        
        # ç»˜åˆ¶è¾¹æ¡†
        self.draw_border()
        
        # æ˜¾ç¤ºæ ‡é¢˜
        title = f"ğŸ“– {get_text('novel_reader', self.lang)} - {get_text('loading', self.lang)}"
        self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
        self.stdscr.addstr(2, max_x // 2 - len(title) // 2, title)
        self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
        
        # æ˜¾ç¤ºæ¶ˆæ¯
        self.stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
        self.stdscr.addstr(max_y // 2 - 2, max_x // 2 - len(message) // 2, message)
        self.stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
        
        # æ˜¾ç¤ºåŠ¨æ€æ—‹è½¬å›¾æ ‡
        spinner_chars = ["â£¾", "â£½", "â£»", "â¢¿", "â¡¿", "â£Ÿ", "â£¯", "â£·"]
        spinner = spinner_chars[int(time.time() * 8) % len(spinner_chars)]
        self.stdscr.attron(curses.color_pair(3) | curses.A_BOLD)
        self.stdscr.addstr(max_y // 2, max_x // 2 - 1, spinner)
        self.stdscr.attroff(curses.color_pair(3) | curses.A_BOLD)
        
        # æ˜¾ç¤ºè¿›åº¦æ¡ï¼ˆå¦‚æœæœ‰è¿›åº¦ä¿¡æ¯ï¼‰
        if progress is not None:
            # è§£æè¿›åº¦ä¿¡æ¯
            if "/" in progress:
                current, total = progress.split("/")
                try:
                    current_val = int(current)
                    total_val = int(total)
                    percent = current_val / total_val if total_val > 0 else 0
                    
                    # ç»˜åˆ¶è¿›åº¦æ¡
                    bar_width = min(40, max_x - 10)
                    filled = int(bar_width * percent)
                    bar = "[" + "â–ˆ" * filled + "â–‘" * (bar_width - filled) + "]"
                    bar_text = f"{bar} {int(percent*100)}%"
                    
                    self.stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
                    self.stdscr.addstr(max_y // 2 + 2, max_x // 2 - len(bar_text) // 2, bar_text)
                    self.stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
                    
                    # æ˜¾ç¤ºè¯¦ç»†è¿›åº¦
                    detail_text = f"{current_val}/{total_val}"
                    self.stdscr.attron(curses.color_pair(3))
                    self.stdscr.addstr(max_y // 2 + 4, max_x // 2 - len(detail_text) // 2, detail_text)
                    self.stdscr.attroff(curses.color_pair(3))
                except:
                    pass
        
        # æ˜¾ç¤ºæç¤ºä¿¡æ¯
        tip = f"{get_text('wait_for_loading', self.lang)}..."
        self.stdscr.attron(curses.color_pair(1) | curses.A_DIM)
        self.stdscr.addstr(max_y - 3, max_x // 2 - len(tip) // 2, tip)
        self.stdscr.attroff(curses.color_pair(1) | curses.A_DIM)
        
        self.stdscr.refresh()

    def load_book(self, book):
        # ä½¿ç”¨è®¾ç½®çš„å®½åº¦ï¼Œè€Œä¸æ˜¯æœ‰æ•ˆå®½åº¦
        width = self.settings["width"]
        height = self.get_safe_height()
        line_spacing = self.settings["line_spacing"]
        
        # æ˜¾ç¤ºåŠ è½½å±å¹•
        self.show_loading_screen(get_text("loading_books", self.lang))
        time.sleep(0.5)  # çŸ­æš‚å»¶è¿Ÿè®©ç”¨æˆ·çœ‹åˆ°åˆå§‹ç”»é¢
        
        # è¿›åº¦å›è°ƒå‡½æ•°
        def progress_callback(message):
            # è§£ææ¶ˆæ¯ä¸­çš„è¿›åº¦ä¿¡æ¯
            progress = None
            if ":" in message and "/" in message:
                parts = message.split(":")
                if len(parts) > 1 and "/" in parts[1]:
                    progress = parts[1].strip()
            
            self.show_loading_screen(message, progress)
        
        if book["type"] == "epub":
            self.show_loading_screen(get_text("parsing_epub_data", self.lang))
            chapters = parse_epub(book["path"], width, height, line_spacing, self.lang)
            
            pages = []
            total_chapters = len(chapters)
            for i, ch in enumerate(chapters):
                # æ·»åŠ ç« èŠ‚æ ‡é¢˜é¡µ
                pages.append([f"ã€Š{ch['title']}ã€‹"])
                # æ·»åŠ ç« èŠ‚å†…å®¹é¡µ
                pages.extend(ch["pages"])
                
                # æ¯å¤„ç†ä¸€ç« æ›´æ–°ä¸€æ¬¡æ˜¾ç¤º
                if i % 2 == 0:  # æ¯ä¸¤ç« æ›´æ–°ä¸€æ¬¡ï¼Œé¿å…è¿‡äºé¢‘ç¹
                    self.show_loading_screen(f"{get_text('action_document_line', self.lang)}: {i+1}/{total_chapters}")
            
            self.current_pages = pages
            self.show_loading_screen(get_text("action_pages", self.lang))
            time.sleep(0.5)
        else:
            # ä½¿ç”¨æ–°ç‰ˆ utils.build_pages_from_fileï¼Œç¡®ä¿ä¸ä¸¢å¤±ä»»ä½•å†…å®¹
            self.current_pages = build_pages_from_file(
                book["path"], width, height, line_spacing, progress_callback, self.lang
            )
            self.show_loading_screen(get_text("action_pages", self.lang))
            time.sleep(0.5)
        # åœ¨è§£æå®Œæˆåæ£€æŸ¥æ˜¯å¦ä¸ºç©º
        if not self.current_pages:
            self.current_pages = [[get_text("empty_file_or_cannot_read", self.lang)]]
        

        self.current_book = book
        self.current_page_idx = self.db.get_progress(book["id"])
        self.highlight_lines = set()

    def show_bookshelf(self):
        """æ˜¾ç¤ºä¹¦æ¶ç•Œé¢ï¼Œæ”¯æŒæ ‡ç­¾è¿‡æ»¤å’Œæ‰¹é‡ç¼–è¾‘"""
        books_per_page = max(1, self.get_safe_height() - 8)
        page = 0
        search_keyword = ""
        
        # åˆå§‹è¿‡æ»¤ä¹¦ç±åˆ—è¡¨
        filtered_books = self.bookshelf.books
        
        # å¦‚æœæœ‰é€‰ä¸­çš„æ ‡ç­¾ï¼ŒæŒ‰æ ‡ç­¾è¿‡æ»¤
        if self.selected_tags:
            filtered_books = [
                book for book in filtered_books 
                if any(tag in book["tags"] for tag in self.selected_tags)
            ]
        
        # å¦‚æœæœ‰æœç´¢å…³é”®è¯ï¼Œè¿›ä¸€æ­¥è¿‡æ»¤
        if search_keyword:
            filtered_books = [
                book for book in filtered_books 
                if search_keyword.lower() in book["title"].lower()
            ]
        
        # æŒ‰æ ‡é¢˜æ’åº
        filtered_books.sort(key=lambda x: x["title"].lower())
        
        current_selection = 0
        book_selected = False
        tag_mode = False  # æ ‡ç­¾æ¨¡å¼æ ‡å¿—
        selected_book_ids = set()  # å­˜å‚¨é€‰ä¸­çš„ä¹¦ç±ID
        
        while not book_selected and self.running:
            self.stdscr.clear()
            max_y, max_x = self.stdscr.getmaxyx()
            total_books = len(filtered_books)
            total_pages = (total_books + books_per_page - 1) // books_per_page if total_books else 1
            start_idx = page * books_per_page
            end_idx = min(start_idx + books_per_page, total_books)
            current_page_books = filtered_books[start_idx:end_idx]
            
            # æ˜¾ç¤ºæ ‡é¢˜å’Œæ ‡ç­¾ä¿¡æ¯
            title_str = "ğŸ“š " + get_text("bookshelf", self.lang) + f" [{page+1}/{total_pages}]"
            if search_keyword:
                title_str += f" | {get_text('search', self.lang)}: {search_keyword}"
            if self.selected_tags:
                title_str += f" | æ ‡ç­¾: {', '.join(self.selected_tags)}"
            if tag_mode:
                title_str += f" | å¤šé€‰æ¨¡å¼: å·²é€‰ {len(selected_book_ids)} æœ¬"
                
            self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            self.stdscr.addstr(0, max_x // 2 - len(title_str) // 2, title_str)
            self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
            
            # æ˜¾ç¤ºä¹¦ç±åˆ—è¡¨
            for idx, book in enumerate(current_page_books):
                exists = "" if book["exists"] else "âŒ"
                selected = "[âœ“]" if book["id"] in selected_book_ids else "[ ]"
                tags_str = ",".join(book["tags"]) if book["tags"] else "æ— æ ‡ç­¾"
                line = f" {selected} {start_idx+idx+1:02d} | {exists} {book['title'][:25]:<25} | {get_text('author', self.lang)}:{book['author'][:15]:<15} | {get_text('tag', self.lang)}:{tags_str}"
                
                # æ ¹æ®æ–‡ä»¶æ˜¯å¦å­˜åœ¨è®¾ç½®é¢œè‰²
                if not book["exists"]:
                    color = curses.color_pair(3)  # çº¢è‰²ï¼Œè¡¨ç¤ºæ–‡ä»¶ä¸å­˜åœ¨
                else:
                    color = curses.color_pair(2) if idx % 2 else curses.color_pair(1)
                
                # å¦‚æœæ˜¯å½“å‰é€‰ä¸­çš„è¡Œï¼Œæ·»åŠ åè‰²æ•ˆæœ
                if idx == current_selection:
                    color |= curses.A_REVERSE
                    
                self.stdscr.attron(color | curses.A_BOLD)
                self.stdscr.addstr(idx+2, 2, line[:max_x-3])
                self.stdscr.attroff(color | curses.A_BOLD)
                    
            # æ˜¾ç¤ºæ“ä½œæç¤º
            help_lines = [
                f"[a] {get_text('add_book', self.lang)}  [d] {get_text('add_dir', self.lang)} [/] {get_text('search', self.lang)}",
                f"[t] æ ‡ç­¾ç®¡ç† [e] ç¼–è¾‘ä¹¦ç± [x] {get_text('delete', self.lang)}  [q] {get_text('exit', self.lang)}",
            ]
            
            if tag_mode:
                help_lines.append(f"[l] é€€å‡ºå¤šé€‰æ¨¡å¼ [ç©ºæ ¼] é€‰æ‹©/å–æ¶ˆ [b] æ‰¹é‡ç¼–è¾‘æ ‡ç­¾ [a] å…¨é€‰ [c] å–æ¶ˆå…¨é€‰")
            else:
                help_lines.append(f"[l] è¿›å…¥å¤šé€‰æ¨¡å¼ [Enter] {get_text('select', self.lang)}")
            
            for i, line in enumerate(help_lines):
                self.stdscr.attron(curses.color_pair(3) | curses.A_DIM)
                self.stdscr.addstr(books_per_page+3+i, 2, line[:max_x-3])
                self.stdscr.attroff(curses.color_pair(3) | curses.A_DIM)
                
            self.stdscr.refresh()
            
            c = self.stdscr.getch()
            if c == ord('a'):
                if tag_mode:
                    # åœ¨å¤šé€‰æ¨¡å¼ä¸‹ï¼Œå…¨é€‰å½“å‰é¡µ
                    for book in current_page_books:
                        selected_book_ids.add(book["id"])
                else:
                    # æ­£å¸¸æ¨¡å¼ä¸‹æ·»åŠ ä¹¦ç±
                    path = input_box(self.stdscr, get_text("input_path", self.lang), maxlen=120)
                    if path:
                        self.bookshelf.add_book(path, width=self.settings["width"], height=self.settings["height"], line_spacing=self.settings["line_spacing"])
                        # åˆ·æ–°ä¹¦ç±åˆ—è¡¨
                        self.bookshelf.books = self.bookshelf.load_books()
                        # é‡æ–°åº”ç”¨è¿‡æ»¤
                        filtered_books = self.bookshelf.books
                        if search_keyword:
                            filtered_books = [book for book in filtered_books if search_keyword.lower() in book["title"].lower()]
                        if self.selected_tags:
                            filtered_books = [book for book in filtered_books if any(tag in book["tags"] for tag in self.selected_tags)]
            elif c == ord('d'):
                dir_path = input_box(self.stdscr, get_text("input_dir", self.lang), maxlen=120)
                if dir_path:
                    self.bookshelf.add_dir(dir_path, width=self.settings["width"], height=self.settings["height"], line_spacing=self.settings["line_spacing"])
                    # åˆ·æ–°ä¹¦ç±åˆ—è¡¨
                    self.bookshelf.books = self.bookshelf.load_books()
                    # é‡æ–°åº”ç”¨è¿‡æ»¤
                    filtered_books = self.bookshelf.books
                    if search_keyword:
                        filtered_books = [book for book in filtered_books if search_keyword.lower() in book["title"].lower()]
                    if self.selected_tags:
                        filtered_books = [book for book in filtered_books if any(tag in book["tags"] for tag in self.selected_tags)]
            elif c == ord('/'):
                kw = input_box(self.stdscr, get_text("input_search", self.lang), maxlen=30)
                search_keyword = kw
                page = 0
                current_selection = 0
                # é‡æ–°åº”ç”¨è¿‡æ»¤
                filtered_books = self.bookshelf.books
                if search_keyword:
                    filtered_books = [book for book in filtered_books if search_keyword.lower() in book["title"].lower()]
                if self.selected_tags:
                    filtered_books = [book for book in filtered_books if any(tag in book["tags"] for tag in self.selected_tags)]
            elif c == ord('x'):
                if tag_mode and selected_book_ids:
                    # åœ¨å¤šé€‰æ¨¡å¼ä¸‹åˆ é™¤é€‰ä¸­çš„ä¹¦ç±
                    confirm = input_box(self.stdscr, f"ç¡®è®¤åˆ é™¤ {len(selected_book_ids)} æœ¬ä¹¦ç±? (y/N): ", maxlen=1)
                    if confirm.lower() == 'y':
                        self.bookshelf.delete_books(list(selected_book_ids))
                        selected_book_ids.clear()
                        # åˆ·æ–°ä¹¦ç±åˆ—è¡¨
                        self.bookshelf.books = self.bookshelf.load_books()
                        # é‡æ–°åº”ç”¨è¿‡æ»¤
                        filtered_books = self.bookshelf.books
                        if search_keyword:
                            filtered_books = [book for book in filtered_books if search_keyword.lower() in book["title"].lower()]
                        if self.selected_tags:
                            filtered_books = [book for book in filtered_books if any(tag in book["tags"] for tag in self.selected_tags)]
                else:
                    self.show_book_deletion()
                    # åˆ·æ–°ä¹¦ç±åˆ—è¡¨
                    self.bookshelf.books = self.bookshelf.load_books()
                    # é‡æ–°åº”ç”¨è¿‡æ»¤
                    filtered_books = self.bookshelf.books
                    if search_keyword:
                        filtered_books = [book for book in filtered_books if search_keyword.lower() in book["title"].lower()]
                    if self.selected_tags:
                        filtered_books = [book for book in filtered_books if any(tag in book["tags"] for tag in self.selected_tags)]
            elif c == ord('t'):
                self.show_tag_management()
                # åˆ·æ–°ä¹¦ç±åˆ—è¡¨
                self.bookshelf.books = self.bookshelf.load_books()
                # é‡æ–°åº”ç”¨è¿‡æ»¤
                filtered_books = self.bookshelf.books
                if search_keyword:
                    filtered_books = [book for book in filtered_books if search_keyword.lower() in book["title"].lower()]
                if self.selected_tags:
                    filtered_books = [book for book in filtered_books if any(tag in book["tags"] for tag in self.selected_tags)]
            elif c == ord('e'):
                if current_page_books:
                    book = current_page_books[current_selection]
                    self.edit_book_metadata(book["id"])
                    # åˆ·æ–°ä¹¦ç±åˆ—è¡¨
                    self.bookshelf.books = self.bookshelf.load_books()
                    # é‡æ–°åº”ç”¨è¿‡æ»¤
                    filtered_books = self.bookshelf.books
                    if search_keyword:
                        filtered_books = [book for book in filtered_books if search_keyword.lower() in book["title"].lower()]
                    if self.selected_tags:
                        filtered_books = [book for book in filtered_books if any(tag in book["tags"] for tag in self.selected_tags)]
            elif c == ord('l'):
                # åˆ‡æ¢æ ‡ç­¾æ¨¡å¼
                tag_mode = not tag_mode
                if not tag_mode:
                    # é€€å‡ºå¤šé€‰æ¨¡å¼æ—¶æ¸…ç©ºé€‰æ‹©
                    selected_book_ids.clear()
            elif c == ord('b') and tag_mode and selected_book_ids:
                # æ‰¹é‡ç¼–è¾‘æ ‡ç­¾
                self.show_batch_tag_edit(list(selected_book_ids))
                # åˆ·æ–°ä¹¦ç±åˆ—è¡¨
                self.bookshelf.books = self.bookshelf.load_books()
                # é‡æ–°åº”ç”¨è¿‡æ»¤
                filtered_books = self.bookshelf.books
                if search_keyword:
                    filtered_books = [book for book in filtered_books if search_keyword.lower() in book["title"].lower()]
                if self.selected_tags:
                    filtered_books = [book for book in filtered_books if any(tag in book["tags"] for tag in self.selected_tags)]
            elif c == ord('c') and tag_mode:
                # å–æ¶ˆå…¨é€‰
                selected_book_ids.clear()
            elif c == ord('q'):
                self.running = False
                break
            elif c == curses.KEY_UP:
                if current_selection > 0:
                    current_selection -= 1
                elif current_selection == 0 and page > 0:
                    page -= 1
                    current_selection = books_per_page - 1
            elif c == curses.KEY_DOWN:
                if current_selection < len(current_page_books) - 1:
                    current_selection += 1
                elif current_selection == len(current_page_books) - 1 and page < total_pages - 1:
                    page += 1
                    current_selection = 0
            elif c == curses.KEY_NPAGE or c == ord('n'):
                if page < total_pages - 1:
                    page += 1
                    current_selection = 0
            elif c == curses.KEY_PPAGE or c == ord('p'):
                if page > 0:
                    page -= 1
                    current_selection = 0
            elif c == ord(' ') and tag_mode:
                # åœ¨å¤šé€‰æ¨¡å¼ä¸‹ï¼Œç©ºæ ¼é”®é€‰æ‹©/å–æ¶ˆé€‰æ‹©å½“å‰ä¹¦ç±
                if current_page_books:
                    book = current_page_books[current_selection]
                    if book["id"] in selected_book_ids:
                        selected_book_ids.remove(book["id"])
                    else:
                        selected_book_ids.add(book["id"])
            elif c in (10, 13) and not tag_mode:  # å›è½¦é”®é€‰æ‹©å½“å‰ä¹¦ç±ï¼ˆéå¤šé€‰æ¨¡å¼ï¼‰
                if current_page_books:
                    book = current_page_books[current_selection]
                    if not book["exists"]:
                        # æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæç¤ºæ›´æ–°è·¯å¾„
                        self.update_missing_book_path(book["id"])
                    else:
                        self.load_book(book)
                        book_selected = True
            elif c in range(48, 58):  # æ•°å­—é”®0-9ï¼Œæ”¯æŒå¿«é€Ÿè·³è½¬
                # ä¿å­˜å½“å‰æŒ‰é”®
                key_char = chr(c)
                # æ˜¾ç¤ºè¾“å…¥çš„æ•°å­—
                self.stdscr.addstr(books_per_page+7, 2, f"{get_text('input_no', self.lang)}: {key_char}")
                self.stdscr.refresh()
                
                # ç­‰å¾…å¯èƒ½çš„ç¬¬äºŒä¸ªæ•°å­—ï¼ˆä¸¤ä½æ•°ï¼‰
                second_c = self.stdscr.getch()
                if second_c in range(48, 58):  # ç¬¬äºŒä¸ªæ•°å­—
                    key_char += chr(second_c)
                    self.stdscr.addstr(books_per_page+7, 2, f"{get_text('input_no', self.lang)}: {key_char}")
                    self.stdscr.refresh()
                    
                try:
                    idx = int(key_char) - 1
                    if 0 <= idx < total_books:
                        book = filtered_books[idx]
                        if not book["exists"]:
                            # æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæç¤ºæ›´æ–°è·¯å¾„
                            self.update_missing_book_path(book["id"])
                        else:
                            self.load_book(book)
                            book_selected = True
                    else:
                        self.stdscr.addstr(books_per_page+7, 2, get_text('no_limited', self.lang))
                        self.stdscr.refresh()
                        time.sleep(1)
                except:
                    self.stdscr.addstr(books_per_page+7, 2, get_text('invalid', self.lang))
                    self.stdscr.refresh()
                    time.sleep(1)

    def show_tag_management(self):
        """æ˜¾ç¤ºæ ‡ç­¾ç®¡ç†ç•Œé¢ - ä¿®å¤åˆ é™¤åŠŸèƒ½"""
        all_tags = self.bookshelf.get_all_tags()
        selected_tags = self.selected_tags.copy()
        current_selection = 0
        
        while True:
            self.stdscr.clear()
            max_y, max_x = self.stdscr.getmaxyx()
            
            # æ˜¾ç¤ºæ ‡é¢˜
            title = "ğŸ·ï¸ æ ‡ç­¾ç®¡ç†"
            self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            self.stdscr.addstr(0, max_x // 2 - len(title) // 2, title)
            self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
            
            # æ˜¾ç¤ºåˆ†éš”çº¿
            sep_line = "â”€" * (max_x - 4)
            self.stdscr.attron(curses.color_pair(10))
            self.stdscr.addstr(1, 2, sep_line)
            self.stdscr.attroff(curses.color_pair(10))
            
            # æ˜¾ç¤ºæ ‡ç­¾åˆ—è¡¨
            for idx, tag in enumerate(all_tags):
                selected = "[âœ“]" if tag in selected_tags else "[ ]"
                line = f" {selected} {tag}"
                
                color = curses.color_pair(2) if idx % 2 else curses.color_pair(1)
                if idx == current_selection:
                    color |= curses.A_REVERSE
                    
                self.stdscr.attron(color)
                self.stdscr.addstr(idx+3, 4, line[:max_x-8])
                self.stdscr.attroff(color)
            
            # æ˜¾ç¤ºæ“ä½œæç¤º
            help_text = "[ç©ºæ ¼] é€‰æ‹©/å–æ¶ˆ [a] æ·»åŠ æ ‡ç­¾ [d] åˆ é™¤æ ‡ç­¾ [Enter] åº”ç”¨ç­›é€‰ [q] è¿”å›"
            self.stdscr.attron(curses.color_pair(3) | curses.A_DIM)
            self.stdscr.addstr(max_y-3, 4, help_text[:max_x-8])
            self.stdscr.attroff(curses.color_pair(3) | curses.A_DIM)
            
            # æ˜¾ç¤ºåˆ†éš”çº¿
            self.stdscr.attron(curses.color_pair(10))
            self.stdscr.addstr(max_y-4, 2, sep_line)
            self.stdscr.attroff(curses.color_pair(10))
            
            self.stdscr.refresh()
            
            c = self.stdscr.getch()
            if c == ord('q'):
                break
            elif c == curses.KEY_UP:
                if current_selection > 0:
                    current_selection -= 1
            elif c == curses.KEY_DOWN:
                if current_selection < len(all_tags) - 1:
                    current_selection += 1
            elif c == ord(' '):  # ç©ºæ ¼é”®é€‰æ‹©/å–æ¶ˆé€‰æ‹©æ ‡ç­¾
                if all_tags:
                    tag = all_tags[current_selection]
                    if tag in selected_tags:
                        selected_tags.remove(tag)
                    else:
                        selected_tags.add(tag)
            elif c == ord('a'):  # æ·»åŠ æ–°æ ‡ç­¾
                new_tag = input_box(self.stdscr, "è¾“å…¥æ–°æ ‡ç­¾åç§°: ", maxlen=20)
                if new_tag:
                    # æ£€æŸ¥æ ‡ç­¾æ˜¯å¦å·²å­˜åœ¨
                    if new_tag not in all_tags:
                        self.bookshelf.db.add_tag(new_tag)
                        all_tags = self.bookshelf.get_all_tags()  # åˆ·æ–°æ ‡ç­¾åˆ—è¡¨
                    else:
                        # æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                        self.stdscr.addstr(max_y-2, 4, "æ ‡ç­¾å·²å­˜åœ¨!")
                        self.stdscr.refresh()
                        time.sleep(1)
            elif c == ord('d'):  # åˆ é™¤æ ‡ç­¾
                if all_tags:
                    tag = all_tags[current_selection]
                    confirm = input_box(self.stdscr, f"ç¡®è®¤åˆ é™¤æ ‡ç­¾ '{tag}'? (y/N): ", maxlen=1)
                    if confirm.lower() == 'y':
                        if self.bookshelf.delete_tag(tag):
                            # ä»æ‰€æœ‰æ ‡ç­¾åˆ—è¡¨ä¸­ç§»é™¤
                            all_tags = self.bookshelf.get_all_tags()
                            # ä»é€‰ä¸­æ ‡ç­¾ä¸­ç§»é™¤
                            if tag in selected_tags:
                                selected_tags.remove(tag)
                            # æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                            self.stdscr.addstr(max_y-2, 4, f"å·²åˆ é™¤æ ‡ç­¾: {tag}")
                            self.stdscr.refresh()
                            time.sleep(1)
                        else:
                            # æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                            self.stdscr.addstr(max_y-2, 4, "åˆ é™¤æ ‡ç­¾å¤±è´¥!")
                            self.stdscr.refresh()
                            time.sleep(1)
            elif c in (10, 13):  # å›è½¦é”®åº”ç”¨ç­›é€‰
                self.selected_tags = selected_tags
                break
        
        # è¿”å›ä¹¦æ¶ä¸»ç•Œé¢
        self.show_bookshelf()

    def edit_book_metadata(self, book_id):
        """ç¼–è¾‘ä¹¦ç±å…ƒæ•°æ®"""
        book = self.bookshelf.get_book_by_id(book_id)
        if not book:
            return
            
        # è·å–å½“å‰ä¿¡æ¯
        current_title = book["title"]
        current_author = book["author"]
        current_tags = ",".join(book["tags"])
        
        # æ˜¾ç¤ºç¼–è¾‘ç•Œé¢
        self.stdscr.clear()
        max_y, max_x = self.stdscr.getmaxyx()
        
        title = "ğŸ“ ç¼–è¾‘ä¹¦ç±ä¿¡æ¯"
        self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
        self.stdscr.addstr(0, max_x // 2 - len(title) // 2, title)
        self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
        
        # æ˜¾ç¤ºå½“å‰ä¿¡æ¯
        self.stdscr.addstr(2, 4, f"ä¹¦å: {current_title}")
        self.stdscr.addstr(3, 4, f"ä½œè€…: {current_author}")
        self.stdscr.addstr(4, 4, f"æ ‡ç­¾: {current_tags}")
        
        # æ˜¾ç¤ºæ“ä½œæç¤º
        help_text = "[t] ç¼–è¾‘æ ‡é¢˜ [a] ç¼–è¾‘ä½œè€… [g] ç¼–è¾‘æ ‡ç­¾ [q] è¿”å›"
        self.stdscr.attron(curses.color_pair(3) | curses.A_DIM)
        self.stdscr.addstr(6, 4, help_text[:max_x-8])
        self.stdscr.attroff(curses.color_pair(3) | curses.A_DIM)
        
        self.stdscr.refresh()
        
        while True:
            c = self.stdscr.getch()
            if c == ord('q'):
                break
            elif c == ord('t'):  # ç¼–è¾‘æ ‡é¢˜
                new_title = input_box(self.stdscr, "æ–°ä¹¦å: ", maxlen=100, y=2, x=10)
                if new_title:
                    current_title = new_title
                    self.stdscr.addstr(2, 10, " " * (max_x-20))
                    self.stdscr.addstr(2, 10, current_title)
                    self.stdscr.refresh()
            elif c == ord('a'):  # ç¼–è¾‘ä½œè€…
                new_author = input_box(self.stdscr, "æ–°ä½œè€…: ", maxlen=50, y=3, x=10)
                if new_author:
                    current_author = new_author
                    self.stdscr.addstr(3, 10, " " * (max_x-20))
                    self.stdscr.addstr(3, 10, current_author)
                    self.stdscr.refresh()
            elif c == ord('g'):  # ç¼–è¾‘æ ‡ç­¾
                new_tags = input_box(self.stdscr, "æ–°æ ‡ç­¾(é€—å·åˆ†éš”): ", maxlen=100, y=4, x=10)
                if new_tags is not None:
                    current_tags = new_tags
                    self.stdscr.addstr(4, 10, " " * (max_x-20))
                    self.stdscr.addstr(4, 10, current_tags)
                    self.stdscr.refresh()
            elif c in (10, 13):  # å›è½¦é”®ä¿å­˜
                self.bookshelf.update_book_metadata(book_id, current_title, current_author, current_tags)
                break

    def draw_border(self):
        style = self.settings["border_style"]
        color = self.settings["border_color"]
        max_y, max_x = self.stdscr.getmaxyx()
        v, h, c = BORDER_CHARS.get(style, BORDER_CHARS["round"])
        border_color_pair = color_pair_idx(10, color, self.settings["bg_color"])
        if style != "none":
            for i in range(1, max_y-2):
                self.stdscr.attron(border_color_pair)
                self.stdscr.addstr(i, 0, v)
                self.stdscr.addstr(i, max_x-2, v)
                self.stdscr.attroff(border_color_pair)
            for i in range(1, max_x-2):
                self.stdscr.attron(border_color_pair)
                self.stdscr.addstr(0, i, h)
                self.stdscr.addstr(max_y-2, i, h)
                self.stdscr.attroff(border_color_pair)
            self.stdscr.attron(border_color_pair)
            self.stdscr.addstr(0, 0, c)
            self.stdscr.addstr(0, max_x-2, c)
            self.stdscr.addstr(max_y-2, 0, c)
            self.stdscr.addstr(max_y-2, max_x-2, c)
            self.stdscr.attroff(border_color_pair)

    def display(self):
        self.stdscr.clear()
        max_y, max_x = self.stdscr.getmaxyx()
        margin = self.settings["margin"]
        padding = self.settings["padding"]
        height = self.get_safe_height()
        self.draw_border()

        # æ·»åŠ å¯¹ç©ºé¡µé¢çš„æ£€æŸ¥
        if not self.current_pages:
            empty_msg = f"{get_text('empty_file_or_cannot_read', self.lang)}"
            self.stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
            self.stdscr.addstr(margin + height // 2, max_x // 2 - len(empty_msg) // 2, empty_msg)
            self.stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
            self.stdscr.refresh()
            return
        
        page_lines = self.current_pages[self.current_page_idx] if self.current_pages else []
        if self.current_pages and self.current_book:
            progress = int((self.current_page_idx+1)/len(self.current_pages)*100)
            bar_len = int(progress / 5)
            
            title_str = f"ã€Š{self.current_book['title']}ã€‹{get_text('reading_progress', self.lang)}:[{'â–ˆ'*bar_len}{'-'*(20-bar_len)}] {progress:3d}%"
            self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            self.stdscr.addstr(margin, max_x // 2 - len(title_str)//2, title_str[:max_x-4])
            self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
            
        for idx, line in enumerate(page_lines[:height]):
            y = idx + margin + 2
            x = padding + 2
            if y >= max_y - 7:
                break
            safe_line = line.replace('\r', '').replace('\n', '').replace('\t', ' ')
            # æ˜¾ç¤ºæ—¶æˆªæ–­åˆ°å±å¹•å®½åº¦
            safe_line = safe_line[:max_x - x - 3] if len(safe_line) > (max_x - x - 3) else safe_line
            try:
                if safe_line.startswith("ã€Š") and safe_line.endswith("ã€‹"):
                    self.stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
                    self.stdscr.addstr(y, x, safe_line.center(self.settings["width"])[:max_x - x - 3])
                    self.stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
                elif idx in self.highlight_lines:
                    self.stdscr.attron(curses.color_pair(2) | curses.A_REVERSE)
                    self.stdscr.addstr(y, x, safe_line)
                    self.stdscr.attroff(curses.color_pair(2) | curses.A_REVERSE)
                else:
                    self.stdscr.attron(curses.color_pair(1))
                    self.stdscr.addstr(y, x, safe_line)
                    self.stdscr.attroff(curses.color_pair(1))
            except curses.error:
                pass
                
        if self.current_pages:
            bar = f""
            self.stdscr.attron(curses.color_pair(3) | curses.A_BOLD)
            self.stdscr.addstr(margin+height+1, 2, bar[:max_x-4])
            self.stdscr.attroff(curses.color_pair(3) | curses.A_BOLD)
            
        if self.settings["status_bar"] and self.current_book:
            status = f"ğŸ“– {self.current_book['title']} | {get_text('author', self.lang)}: {self.current_book['author']} | {get_text('current_page', self.lang)}: {self.current_page_idx+1}/{len(self.current_pages)}"
            self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            self.stdscr.addstr(margin+height+2, 2, status[:max_x-4])
            self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
            
        # æ˜¾ç¤ºæœ—è¯»çŠ¶æ€
        if self.is_reading:
            reading_status = f"ğŸ”Š {get_text('aloud_r2_stop', self.lang)}"
            self.stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
            self.stdscr.addstr(margin+height+3, 2, reading_status[:max_x-4])
            self.stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
            
        help_str = " | ".join(KEYS_HELP)
        self.stdscr.attron(curses.color_pair(2) | curses.A_DIM)
        self.stdscr.addstr(margin+height+4, 2, help_str[:max_x-4])
        self.stdscr.attroff(curses.color_pair(2) | curses.A_DIM)
        self.stdscr.refresh()

    def handle_input(self):
        c = self.stdscr.getch()
        if self.boss_mode:
            # è€æ¿æ¨¡å¼å…³é—­è‡ªåŠ¨ç¿»é¡µã€æœ—è¯»
            if self.is_reading:
                self.stop_reading()
            if self.is_reading:
                self.stop_reading()

            # åœ¨è€æ¿é”®æ¨¡å¼ä¸‹å¤„ç†è¾“å…¥
            self.handle_terminal_input(c)
            return

        if c == ord(' '):  # ç©ºæ ¼é”® - è€æ¿é”®
            self.toggle_boss_mode()
        elif c in (curses.KEY_RIGHT, curses.KEY_NPAGE, ord('j')):
            if self.is_reading:
                self.stop_reading()
            self.next_page()
        elif c in (curses.KEY_LEFT, curses.KEY_PPAGE, ord('k')):
            if self.is_reading:
                self.stop_reading()
            self.prev_page()
        elif c == ord('a'):
            if self.is_reading:
                self.stop_reading()
            self.auto_page = not self.auto_page
        elif c == ord('b'):
            if self.is_reading:
                self.stop_reading()
            self.add_bookmark()
        elif c == ord('B'):
            if self.is_reading:
                self.stop_reading()
            self.show_bookmarks()
        elif c == ord('m'):
            if self.is_reading:
                self.stop_reading()
            self.show_bookshelf()
        elif c == ord('q'):
            self.running = False
        elif c == ord('r'):
            self.toggle_reading()  # ä¿®æ”¹ä¸ºåˆ‡æ¢æœ—è¯»çŠ¶æ€
        elif c == ord('/'):
            if self.is_reading:
                self.stop_reading()
            self.search()
        elif c == ord('s'):
            if self.is_reading:
                self.stop_reading()
            self.change_settings()
        elif c == ord('?'):
            if self.is_reading:
                self.stop_reading()
            self.show_help()
        elif c == ord('g'):
            if self.is_reading:
                self.stop_reading()
            self.jump_page()
        elif c == ord('t'):
            if self.is_reading:
                self.stop_reading()
            self.show_stats()
        elif c == ord('T'):
            if self.is_reading:
                self.stop_reading()
            self.show_all_books_stats()

    def next_page(self):
        if self.current_page_idx < len(self.current_pages)-1:
            self.current_page_idx += 1

    def prev_page(self):
        if self.current_page_idx > 0:
            self.current_page_idx -= 1

    def save_progress(self):
        if self.current_book:
            self.db.save_progress(self.current_book["id"], self.current_page_idx)

    def show_bookmarks(self):
        bookmarks = self.db.get_bookmarks(self.current_book["id"])
        max_y, max_x = self.stdscr.getmaxyx()
        self.stdscr.clear()
        self.stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
        self.stdscr.addstr(0, max_x // 2 - 5, get_text("bookmark_list", self.lang))
        self.stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
        for i, (page, comment) in enumerate(bookmarks[:max_y-8]):
            self.stdscr.addstr(i+2, 4, f"{i+1:02d}. {get_text('page_no', self.lang).format(page=page+1)}: {comment}"[:max_x-8])
        self.stdscr.attron(curses.color_pair(3) | curses.A_DIM)
        self.stdscr.addstr(max_y-4, 4, get_text('input_jump_page_quit', self.lang))
        self.stdscr.attroff(curses.color_pair(3) | curses.A_DIM)
        self.stdscr.refresh()
        c = self.stdscr.getch()
        if c == ord('q'):
            return
        elif c in [10, 13]:
            idx_str = input_box(self.stdscr, f"{get_text('number', self.lang)}: ", maxlen=8)
            try:
                idx = int(idx_str) - 1
                if 0 <= idx < len(bookmarks):
                    self.current_page_idx = bookmarks[idx][0]
                else:
                    self.stdscr.addstr(max_y-2, 4, get_text('no_unlimited', self.lang))
                    self.stdscr.refresh()
                    time.sleep(1)
            except:
                self.stdscr.addstr(max_y-2, 4, get_text('invalid', self.lang))
                self.stdscr.refresh()
                time.sleep(1)

    def jump_page(self):
        max_y, max_x = self.stdscr.getmaxyx()
        page_str = input_box(self.stdscr, get_text("input_jump_page", self.lang), maxlen=10)
        try:
            page_num = int(page_str)
            if 1 <= page_num <= len(self.current_pages):
                self.current_page_idx = page_num - 1
            else:
                self.stdscr.addstr(max_y-3, 2, get_text("invalid", self.lang))
                self.stdscr.refresh()
                time.sleep(1)
        except:
            self.stdscr.addstr(max_y-3, 2, get_text("invalid", self.lang))
            self.stdscr.refresh()
            time.sleep(1)

    def add_bookmark(self):
        comment = input_box(self.stdscr, get_text("input_comment", self.lang), maxlen=100)
        if comment:
            self.db.add_bookmark(self.current_book["id"], self.current_page_idx, comment)

    def toggle_reading(self):
        """åˆ‡æ¢æœ—è¯»çŠ¶æ€"""
        if self.is_reading:
            self.stop_reading()
        else:
            self.start_reading()

    def start_reading(self):
        """å¼€å§‹æœ—è¯»"""
        if self.is_reading:
            return
            
        # å¼€å§‹æœ—è¯»
        self.is_reading = True
        txt = "\n".join(self.current_pages[self.current_page_idx])
        
        # ä½¿ç”¨çº¿ç¨‹æ¥è¿è¡Œæœ—è¯»ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
        def run_reading():
            try:
                self.engine.say(txt)
                self.engine.runAndWait()
            except Exception as e:
                # å¿½ç•¥æ‰€æœ‰å¼‚å¸¸ï¼Œç‰¹åˆ«æ˜¯KeyboardInterrupt
                pass
            finally:
                self.is_reading = False
                
        self.reading_thread = threading.Thread(target=run_reading)
        self.reading_thread.daemon = True
        self.reading_thread.start()

    def stop_reading(self):
        """åœæ­¢æœ—è¯»"""
        if self.is_reading:
            try:
                self.engine.stop()
                # ç­‰å¾…ä¸€å°æ®µæ—¶é—´è®©å¼•æ“åœæ­¢
                time.sleep(0.1)
                self.is_reading = False
            except Exception:
                self.is_reading = False

    def search(self):
        kw = input_box(self.stdscr, get_text("input_search", self.lang), maxlen=50)
        if kw:
            self.search_keyword = kw
            self.highlight_lines = set()
            page_lines = self.current_pages[self.current_page_idx]
            for idx, line in enumerate(page_lines):
                if kw in line:
                    self.highlight_lines.add(idx)

    def check_remind(self):
        remind_interval = self.settings["remind_interval"]
        if remind_interval and remind_interval > 0:
            now = time.time()
            elapsed = now - self.last_remind_time
            if elapsed > remind_interval * 60:
                self.show_remind(int(elapsed // 60))
                self.last_remind_time = now

    def show_remind(self, minutes):
        max_y, max_x = self.stdscr.getmaxyx()
        msg = get_text("remind_msg", self.lang).format(minutes=minutes)
        box_top = max_y // 2 - 3
        box_left = max_x // 2 - len(msg) // 2 - 2
        self.stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
        self.stdscr.addstr(box_top, box_left, "â•­" + "â”€" * (len(msg)+2) + "â•®")
        self.stdscr.addstr(box_top+1, box_left, "â”‚" + msg + " â”‚")
        self.stdscr.addstr(box_top+2, box_left, "â•°" + "â”€" * (len(msg)+2) + "â•¯")
        self.stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
        self.stdscr.refresh()
        time.sleep(3)

    def change_settings(self):
        options = [
            ("width", "å®½åº¦", int, 40, 300),
            ("height", "é«˜åº¦", int, 10, 80),
            ("theme", get_text("input_theme", self.lang), str, ["dark", "light", "eye"]),
            ("lang", get_text("input_lang", self.lang), str, ["zh", "en"]),
            ("font_color", get_text("input_font_color", self.lang), str, ["black","red","green","yellow","blue","magenta","cyan","white"]),
            ("bg_color", get_text("input_bg_color", self.lang), str, ["black","red","green","yellow","blue","magenta","cyan","white"]),
            ("border_style", get_text("input_border_style", self.lang), str, ["round","double","single","bold","none"]),
            ("border_color", get_text("input_border_color", self.lang), str, ["black","red","green","yellow","blue","magenta","cyan","white"]),
            ("line_spacing", "è¡Œè·", int, 1, 5),
            ("auto_page_interval", "è‡ªåŠ¨ç¿»é¡µç§’", int, 1, 60),
            ("status_bar", "çŠ¶æ€æ æ˜¾ç¤º", bool, [0, 1]),
            ("remind_interval", get_text("input_remind_interval", self.lang), int, 0, 120),
        ]
        curr = 0
        while True:
            self.stdscr.clear()
            max_y, max_x = self.stdscr.getmaxyx()
            self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            self.stdscr.addstr(0, max_x // 2 - 6, "âš™ï¸ è®¾ç½®ç•Œé¢")
            self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
            for idx, (key, desc, typ, *meta) in enumerate(options):
                val = self.settings[key]
                line = f"{desc} [{val}]"
                if idx == curr:
                    self.stdscr.attron(curses.color_pair(2) | curses.A_REVERSE)
                    self.stdscr.addstr(idx+2, 4, line[:max_x-8])
                    self.stdscr.attroff(curses.color_pair(2) | curses.A_REVERSE)
                else:
                    self.stdscr.addstr(idx+2, 4, line[:max_x-8])
            self.stdscr.attron(curses.color_pair(3) | curses.A_DIM)
            self.stdscr.addstr(len(options)+4, 4, "å›è½¦ä¿®æ”¹ï¼Œqè¿”å›")
            self.stdscr.attroff(curses.color_pair(3) | curses.A_DIM)
            self.stdscr.refresh()
            c = self.stdscr.getch()
            if c in (curses.KEY_DOWN, ord('j')):
                curr = (curr + 1) % len(options)
            elif c in (curses.KEY_UP, ord('k')):
                curr = (curr - 1) % len(options)
            elif c == ord('q'):
                init_colors(theme=self.settings["theme"], settings=self.settings)
                self.lang = self.settings["lang"]
                self.remind_minutes = self.settings["remind_interval"]
                # é‡æ–°åŠ è½½å½“å‰ä¹¦ç±ä»¥é€‚åº”æ–°è®¾ç½®
                if self.current_book:
                    self.load_book(self.current_book)
                break
            elif c in (curses.KEY_ENTER, 10, 13):
                key, desc, typ, *meta = options[curr]
                newval = input_box(self.stdscr, f"{desc}æ–°å€¼: ", maxlen=20)
                valid = False
                if typ == int:
                    try:
                        v = int(newval)
                        if len(meta)==2 and (meta[0] <= v <= meta[1]):
                            self.settings[key] = v
                            valid = True
                    except:
                        pass
                elif typ == bool:
                    if newval.lower() in ['1', 'true', 'yes', 'y', 'å¼€', 'æ˜¯']:
                        self.settings[key] = True
                        valid = True
                    elif newval.lower() in ['0', 'false', 'no', 'n', 'å…³', 'å¦']:
                        self.settings[key] = False
                        valid = True
                elif typ == str:
                    if isinstance(meta[0], list) and newval in meta[0]:
                        self.settings[key] = newval
                        valid = True
                if not valid:
                    self.stdscr.addstr(len(options)+7, 4, get_text("invalid", self.lang))
                    self.stdscr.refresh()
                    time.sleep(1)
                else:
                    self.settings.save()
                    if key in ["theme","font_color","bg_color","border_style","border_color"]:
                        init_colors(theme=self.settings["theme"], settings=self.settings)
                    if key == "lang":
                        self.lang = self.settings["lang"]
                    if key == "remind_interval":
                        self.remind_minutes = self.settings["remind_interval"]
                    # é‡æ–°åŠ è½½å½“å‰ä¹¦ç±ä»¥é€‚åº”æ–°è®¾ç½®
                    if self.current_book and key in ["width", "height", "line_spacing"]:
                        self.load_book(self.current_book)

    def show_help(self):
        max_y, max_x = self.stdscr.getmaxyx()
        self.stdscr.clear()
        
        # ç»˜åˆ¶è¾¹æ¡†
        self.draw_border()
        
        # æ ‡é¢˜
        title = "ğŸ’¡ å¸®åŠ©ä¸­å¿ƒ"
        self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
        self.stdscr.addstr(2, max_x // 2 - len(title) // 2, title)
        self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
        
        # åˆ†éš”çº¿
        sep_line = "â”€" * (max_x - 6)
        self.stdscr.attron(curses.color_pair(10))
        self.stdscr.addstr(4, 3, sep_line)
        self.stdscr.attroff(curses.color_pair(10))
        
        # åˆ†ç±»æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
        categories = [
            {
                "title": "ğŸ“– é˜…è¯»æ§åˆ¶",
                "items": [
                    ("â†/â†’/PgUp/PgDn/j/k", "ç¿»é¡µ"),
                    ("a", "è‡ªåŠ¨ç¿»é¡µ"),
                    ("g", "è·³è½¬åˆ°æŒ‡å®šé¡µ"),
                    ("/", "æœç´¢æ–‡æœ¬")
                ]
            },
            {
                "title": "ğŸ”– ä¹¦ç­¾åŠŸèƒ½",
                "items": [
                    ("b", "æ·»åŠ ä¹¦ç­¾"),
                    ("B", "æŸ¥çœ‹ä¹¦ç­¾åˆ—è¡¨")
                ]
            },
            {
                "title": "ğŸµ æœ—è¯»åŠŸèƒ½",
                "items": [
                    ("r", "å¼€å§‹/åœæ­¢æœ—è¯»")
                ]
            },
            {
                "title": "ğŸ“š ä¹¦ç±ç®¡ç†",
                "items": [
                    ("m", "è¿”å›ä¹¦æ¶"),
                    ("s", "è®¾ç½®é€‰é¡¹")
                ]
            },
            {
                "title": "ğŸ“Š ç»Ÿè®¡ä¿¡æ¯",
                "items": [
                    ("t", "æœ¬ä¹¦é˜…è¯»ç»Ÿè®¡"),
                    ("T", "å…¨éƒ¨ä¹¦ç±ç»Ÿè®¡")
                ]
            },
            {
                "title": "ğŸ‘” è€æ¿é”®åŠŸèƒ½",
                "items": [
                    ("ç©ºæ ¼é”®", "éšè—/æ˜¾ç¤ºé˜…è¯»å™¨"),
                    ("ç©ºæ ¼+å›è½¦", "ä»ç»ˆç«¯è¿”å›é˜…è¯»å™¨"),
                    ("â†‘â†“", "æµè§ˆå‘½ä»¤å†å²")
                ]
            },
            {
                "title": "âš™ï¸ ç³»ç»Ÿæ“ä½œ",
                "items": [
                    ("?", "æ˜¾ç¤ºå¸®åŠ©"),
                    ("q", "é€€å‡ºç¨‹åº")
                ]
            }
        ]
        
        y_pos = 6
        for category in categories:
            # æ˜¾ç¤ºåˆ†ç±»æ ‡é¢˜
            self.stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
            self.stdscr.addstr(y_pos, 5, category["title"])
            self.stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
            
            y_pos += 1
            
            # æ˜¾ç¤ºåˆ†ç±»ä¸­çš„é¡¹ç›®
            for key, desc in category["items"]:
                key_part = f"[{key}]"
                desc_part = f" {desc}"
                
                self.stdscr.attron(curses.color_pair(3) | curses.A_BOLD)
                self.stdscr.addstr(y_pos, 7, key_part)
                self.stdscr.attroff(curses.color_pair(3) | curses.A_BOLD)
                
                self.stdscr.attron(curses.color_pair(1))
                self.stdscr.addstr(y_pos, 7 + len(key_part), desc_part)
                self.stdscr.attroff(curses.color_pair(1))
                
                y_pos += 1
            
            y_pos += 1  # åˆ†ç±»ä¹‹é—´çš„é—´éš”
        
        # åº•éƒ¨æç¤º
        tip = "æŒ‰ä»»æ„é”®è¿”å›é˜…è¯»ç•Œé¢"
        self.stdscr.attron(curses.color_pair(1) | curses.A_DIM)
        self.stdscr.addstr(max_y - 3, max_x // 2 - len(tip) // 2, tip)
        self.stdscr.attroff(curses.color_pair(1) | curses.A_DIM)
        
        # è£…é¥°æ€§è¾¹æ¡†
        self.stdscr.attron(curses.color_pair(10))
        self.stdscr.addstr(max_y - 5, 3, sep_line)
        self.stdscr.attroff(curses.color_pair(10))
        
        self.stdscr.refresh()
        self.stdscr.getch()

    def show_stats(self):
        stats = self.stats.get_book_stats(self.current_book["id"])
        max_y, max_x = self.stdscr.getmaxyx()
        self.stdscr.clear()
        self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
        self.stdscr.addstr(0, max_x // 2 - 6, "ğŸ“Š é˜…è¯»ç»Ÿè®¡")
        self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
        self.stdscr.addstr(2, 4, f"å°è¯´ï¼š{self.current_book['title']}")
        self.stdscr.addstr(3, 4, f"ç´¯è®¡é˜…è¯»æ—¶é—´ï¼š{stats['total_time']//60} åˆ†é’Ÿ")
        self.stdscr.addstr(4, 4, f"é˜…è¯»å¤©æ•°ï¼š{stats['days']} å¤©")
        self.stdscr.addstr(6, 4, f"æ¯æ—¥ç»Ÿè®¡ï¼š")
        for idx, (date, sec) in enumerate(stats["records"][:max_y-12]):
            self.stdscr.addstr(7+idx, 6, f"{date}: {sec//60} åˆ†é’Ÿ")
        self.stdscr.addstr(max_y-2, 4, "ä»»æ„é”®è¿”å›")
        self.stdscr.refresh()
        self.stdscr.getch()

    def show_all_books_stats(self):
        all_stats = self.stats.get_all_books_stats()
        # ä¿®æ”¹æ’åºæ–¹å¼ä¸ºæŒ‰æ ‡é¢˜å‡åº
        books = sorted(self.bookshelf.books, key=lambda x: x["title"].lower())
        max_y, max_x = self.stdscr.getmaxyx()
        stats_per_page = max(1, max_y - 7)
        page = 0
        total_books = len(books)
        total_pages = (total_books + stats_per_page - 1) // stats_per_page if total_books else 1
        while True:
            self.stdscr.clear()
            self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            self.stdscr.addstr(0, max_x // 2 - 7, f"ğŸ“š {get_text('stats_all', self.lang)}")
            self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
            start_idx = page * stats_per_page
            end_idx = min(start_idx + stats_per_page, total_books)
            y = 2
            for book in books[start_idx:end_idx]:
                book_id = book["id"]
                stat = all_stats.get(book_id, {"total_time":0, "days":0})
                line = f"{book['title'][:20]:<20} | {stat['total_time']//60:>4} {get_text('minutes', self.lang)} | {stat['days']} {get_text('day', self.lang)}"
                self.stdscr.addstr(y, 4, line[:max_x-8])
                y += 1
            self.stdscr.attron(curses.color_pair(3) | curses.A_DIM)
            page_info = f"{get_text('page_no', self.lang).format(page=f'{page+1}/{total_pages}')} [n] {get_text('next_page', self.lang)} [p] {get_text('pre_page', self.lang)} [q] {get_text('back', self.lang)}"
            self.stdscr.addstr(max_y-3, 4, page_info[:max_x-8])
            self.stdscr.attroff(curses.color_pair(3) | curses.A_DIM)
            self.stdscr.refresh()
            c = self.stdscr.getch()
            if c == ord('q'):
                break
            elif c == ord('n') and page < total_pages - 1:
                page += 1
            elif c == ord('p') and page > 0:
                page -= 1

    def toggle_boss_mode(self):
        """åˆ‡æ¢è€æ¿é”®æ¨¡å¼"""
        self.boss_mode = not self.boss_mode
        if self.boss_mode:
            # è¿›å…¥è€æ¿é”®æ¨¡å¼
            self.terminal_input = ""
            self.terminal_output = [f"{get_text('terminal_mode_started', self.lang)}", f"{get_text('terminal_help_text2', self.lang)}", "----------------------------------------"]
            self.terminal_cursor = 0
        else:
            # é€€å‡ºè€æ¿é”®æ¨¡å¼
            self.terminal_history = []
            self.terminal_position = 0

    def handle_terminal_input(self, c):
        """å¤„ç†ç»ˆç«¯æ¨¡å¼ä¸‹çš„è¾“å…¥"""
        if c == curses.KEY_ENTER or c == 10 or c == 13:  # å›è½¦é”®
            self.execute_terminal_command()
        elif c == curses.KEY_BACKSPACE or c == 127:  # é€€æ ¼é”®
            if self.terminal_input:
                self.terminal_input = self.terminal_input[:-1]
        elif c == curses.KEY_UP:  # ä¸Šç®­å¤´ - å†å²å‘½ä»¤
            if self.terminal_history and self.terminal_position > 0:
                self.terminal_position -= 1
                self.terminal_input = self.terminal_history[self.terminal_position]
        elif c == curses.KEY_DOWN:  # ä¸‹ç®­å¤´ - å†å²å‘½ä»¤
            if self.terminal_history and self.terminal_position < len(self.terminal_history) - 1:
                self.terminal_position += 1
                self.terminal_input = self.terminal_history[self.terminal_position]
            elif self.terminal_position == len(self.terminal_history) - 1:
                self.terminal_position = len(self.terminal_history)
                self.terminal_input = ""
        elif 32 <= c <= 126:  # å¯æ‰“å°å­—ç¬¦
            self.terminal_input += chr(c)
            
        self.display_terminal()

    def execute_terminal_command(self):
        """æ‰§è¡Œç»ˆç«¯å‘½ä»¤"""
        command = self.terminal_input.strip()
        
        # å¦‚æœå‘½ä»¤ä¸ºç©ºæˆ–åªæœ‰ç©ºæ ¼ï¼Œåˆ™é€€å‡ºè€æ¿é”®æ¨¡å¼
        if not command or command.isspace():
            self.toggle_boss_mode()
            return
            
        # å°†å‘½ä»¤æ·»åŠ åˆ°å†å²
        if not self.terminal_history or self.terminal_history[-1] != command:
            self.terminal_history.append(command)
        self.terminal_position = len(self.terminal_history)
        
        # æ‰§è¡Œå‘½ä»¤
        try:
            if command.lower() in ['exit', 'quit']:
                self.terminal_output.append(f"$ {command}")
                self.terminal_output.append(f"{get_text('terminal_help_text2', self.lang)}")
            else:
                self.terminal_output.append(f"$ {command}")
                
                # ä½¿ç”¨subprocessæ‰§è¡Œå‘½ä»¤
                result = subprocess.run(
                    command, 
                    shell=True, 
                    capture_output=True, 
                    text=True, 
                    timeout=30
                )
                
                if result.stdout:
                    self.terminal_output.extend(result.stdout.splitlines())
                if result.stderr:
                    self.terminal_output.extend(result.stderr.splitlines())
                if result.returncode != 0:
                    self.terminal_output.append(f"{get_text('command_exists_code', self.lang)}: {result.returncode}")
                    
        except subprocess.TimeoutExpired:
            self.terminal_output.append(f"{get_text('command_time_unlimit', self.lang)}")
        except Exception as e:
            self.terminal_output.append(f"{get_text('execute_fail', self.lang)}: {str(e)}")
        
        # é™åˆ¶è¾“å‡ºè¡Œæ•°
        if len(self.terminal_output) > 100:
            self.terminal_output = self.terminal_output[-100:]
        
        self.terminal_input = ""
        self.display_terminal()

    def display_terminal(self):
        """æ˜¾ç¤ºç»ˆç«¯ç•Œé¢"""
        self.stdscr.clear()
        max_y, max_x = self.stdscr.getmaxyx()
        
        # æ˜¾ç¤ºç»ˆç«¯æ ‡é¢˜
        title = f"ğŸ’» {get_text('terminal_title', self.lang)}"
        self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
        self.stdscr.addstr(0, max_x // 2 - len(title) // 2, title)
        self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
        
        # æ˜¾ç¤ºåˆ†éš”çº¿
        sep_line = "â”€" * (max_x - 4)
        self.stdscr.attron(curses.color_pair(10))
        self.stdscr.addstr(1, 2, sep_line)
        self.stdscr.attroff(curses.color_pair(10))
        
        # æ˜¾ç¤ºç»ˆç«¯è¾“å‡º
        start_line = max(0, len(self.terminal_output) - (max_y - 6))
        for i, line in enumerate(self.terminal_output[start_line:]):
            if i < max_y - 5:
                # æˆªæ–­è¿‡é•¿çš„è¡Œ
                display_line = line[:max_x-4] if len(line) > max_x-4 else line
                self.stdscr.addstr(i + 2, 2, display_line)
        
        # æ˜¾ç¤ºåˆ†éš”çº¿
        self.stdscr.attron(curses.color_pair(10))
        self.stdscr.addstr(max_y - 3, 2, sep_line)
        self.stdscr.attroff(curses.color_pair(10))
        
        # æ˜¾ç¤ºå‘½ä»¤è¾“å…¥è¡Œ
        prompt = "$ "
        input_line = prompt + self.terminal_input
        # å¦‚æœè¾“å…¥è¡Œå¤ªé•¿ï¼Œæˆªæ–­å¹¶æ˜¾ç¤ºå…‰æ ‡ä½ç½®
        if len(input_line) > max_x - 4:
            start_pos = max(0, len(self.terminal_input) - (max_x - 6))
            display_input = input_line[start_pos:start_pos + max_x - 4]
            cursor_pos = len(prompt) + len(self.terminal_input) - start_pos
        else:
            display_input = input_line
            cursor_pos = len(display_input)
        
        self.stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
        self.stdscr.addstr(max_y - 2, 2, display_input)
        self.stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
        
        # æ˜¾ç¤ºå…‰æ ‡
        if time.time() % 1 < 0.5:  # é—ªçƒå…‰æ ‡
            try:
                self.stdscr.addstr(max_y - 2, 2 + cursor_pos, "_")
            except:
                pass
        
        # æ˜¾ç¤ºå¸®åŠ©æç¤º
        help_text = f"{get_text('terminal_help_text', self.lang)}"
        self.stdscr.attron(curses.color_pair(1) | curses.A_DIM)
        self.stdscr.addstr(max_y - 1, max_x // 2 - len(help_text) // 2, help_text)
        self.stdscr.attroff(curses.color_pair(1) | curses.A_DIM)
        
        self.stdscr.refresh()

    def show_book_deletion(self):
        """æ˜¾ç¤ºä¹¦ç±åˆ é™¤ç•Œé¢"""
        max_y, max_x = self.stdscr.getmaxyx()
        books_per_page = max(1, self.get_safe_height() - 8)
        page = 0
        selected_books = set()  # å­˜å‚¨é€‰ä¸­çš„ä¹¦ç±ID
        current_selection = 0   # å½“å‰é€‰ä¸­çš„è¡Œåœ¨å½“å‰é¡µçš„ç´¢å¼•
        
        while True:
            self.stdscr.clear()
            
            # æ£€æŸ¥ä¹¦ç±å­˜åœ¨çŠ¶æ€
            self.bookshelf.check_books_existence()
            
            # æ˜¾ç¤ºæ ‡é¢˜
            title = f"ğŸ—‘ï¸ {get_text('book_deletion_title', self.lang)}"
            self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            self.stdscr.addstr(0, max_x // 2 - len(title) // 2, title)
            self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
            
            # æ˜¾ç¤ºä¹¦ç±åˆ—è¡¨
            total_books = len(self.bookshelf.books)
            total_pages = (total_books + books_per_page - 1) // books_per_page if total_books else 1
            start_idx = page * books_per_page
            end_idx = min(start_idx + books_per_page, total_books)
            current_page_books = self.bookshelf.books[start_idx:end_idx]
            
            for idx, book in enumerate(current_page_books):
                line_num = start_idx + idx + 1
                selected = "[âœ“]" if book["id"] in selected_books else "[ ]"
                exists = "" if book["exists"] else "âŒ"
                line = f" {selected} {line_num:02d} | {exists} {book['title'][:25]:<25} | {book['author'][:15]:<15}"
                
                # æ ¹æ®é€‰æ‹©çŠ¶æ€å’Œå­˜åœ¨çŠ¶æ€è®¾ç½®é¢œè‰²
                if not book["exists"]:
                    color = curses.color_pair(3)  # çº¢è‰²ï¼Œè¡¨ç¤ºæ–‡ä»¶ä¸å­˜åœ¨
                elif book["id"] in selected_books:
                    color = curses.color_pair(2) | curses.A_BOLD  # é«˜äº®ï¼Œè¡¨ç¤ºå·²é€‰æ‹©
                else:
                    color = curses.color_pair(1)  # æ™®é€šé¢œè‰²
                    
                # å¦‚æœæ˜¯å½“å‰é€‰ä¸­çš„è¡Œï¼Œæ·»åŠ åè‰²æ•ˆæœ
                if idx == current_selection:
                    color |= curses.A_REVERSE
                    
                self.stdscr.attron(color)
                self.stdscr.addstr(idx + 2, 2, line[:max_x-4])
                self.stdscr.attroff(color)
            
            # æ˜¾ç¤ºé¡µç å’Œå¸®åŠ©ä¿¡æ¯
            page_info = f"{get_text('page_no', self.lang).format(page=f'{page+1}/{total_pages}')}"
            self.stdscr.attron(curses.color_pair(3) | curses.A_DIM)
            self.stdscr.addstr(books_per_page + 3, 2, page_info)
            help_text = f"{get_text('book_deletion_help', self.lang)}"
            self.stdscr.addstr(books_per_page + 4, 2, help_text[:max_x-4])
            self.stdscr.attroff(curses.color_pair(3) | curses.A_DIM)
            
            self.stdscr.refresh()
            
            # å¤„ç†è¾“å…¥
            c = self.stdscr.getch()
            if c == ord('q'):  # é€€å‡º
                break
            elif c == curses.KEY_UP:  # ä¸Šç®­å¤´
                if current_selection > 0:
                    current_selection -= 1
                # å¦‚æœå½“å‰åœ¨ç¬¬ä¸€è¡Œï¼Œä¸”ä¸æ˜¯ç¬¬ä¸€é¡µï¼Œå¯ä»¥ç¿»åˆ°ä¸Šä¸€é¡µå¹¶é€‰ä¸­æœ€åä¸€æœ¬ä¹¦
                elif current_selection == 0 and page > 0:
                    page -= 1
                    current_selection = books_per_page - 1
            elif c == curses.KEY_DOWN:  # ä¸‹ç®­å¤´
                if current_selection < len(current_page_books) - 1:
                    current_selection += 1
                # å¦‚æœå½“å‰åœ¨æœ€åä¸€è¡Œçš„ä¸‹ä¸€é¡µè¿˜æœ‰ä¹¦ï¼Œåˆ™ç¿»åˆ°ä¸‹ä¸€é¡µå¹¶é€‰ä¸­ç¬¬ä¸€æœ¬ä¹¦
                elif current_selection == len(current_page_books) - 1 and page < total_pages - 1:
                    page += 1
                    current_selection = 0
            elif c == ord('n') and page < total_pages - 1:  # ä¸‹ä¸€é¡µ
                page += 1
                current_selection = 0  # ç¿»é¡µåé‡ç½®é€‰ä¸­è¡Œä¸ºç¬¬ä¸€è¡Œ
            elif c == ord('p') and page > 0:  # ä¸Šä¸€é¡µ
                page -= 1
                current_selection = 0  # ç¿»é¡µåé‡ç½®é€‰ä¸­è¡Œä¸ºç¬¬ä¸€è¡Œ
            elif c == ord('a'):  # å…¨é€‰
                selected_books = set(book["id"] for book in self.bookshelf.books)
            elif c == ord('c'):  # å–æ¶ˆå…¨é€‰
                selected_books.clear()
            elif c == ord(' '):  # é€‰æ‹©/å–æ¶ˆé€‰æ‹©å½“å‰è¡Œ
                if current_page_books:
                    book_id = current_page_books[current_selection]["id"]
                    if book_id in selected_books:
                        selected_books.remove(book_id)
                    else:
                        selected_books.add(book_id)
            elif c in (10, 13):  # å›è½¦é”®ï¼Œç¡®è®¤åˆ é™¤
                if selected_books:
                    selected_books_len=len(selected_books)
                    # ç¡®è®¤åˆ é™¤
                    confirm = input_box(self.stdscr, f"{get_text('book_deletion_confirm', self.lang).format(books=selected_books_len)} (y/N): ", maxlen=1)
                    if confirm.lower() == 'y':
                        self.bookshelf.delete_books(selected_books)
                        selected_books.clear()
                        # æ˜¾ç¤ºåˆ é™¤æˆåŠŸæ¶ˆæ¯
                        msg = f"{get_text('book_deletion_success', self.lang).format(books=selected_books_len)}"
                        self.stdscr.addstr(books_per_page + 6, 2, msg)
                        self.stdscr.refresh()
                        time.sleep(1)
                        # åˆ é™¤åé‡æ–°åŠ è½½ä¹¦ç±åˆ—è¡¨
                        self.bookshelf.books = self.bookshelf.load_books()
                        # å¦‚æœå½“å‰é¡µæ²¡æœ‰ä¹¦ç±äº†ï¼Œä¸”ä¸æ˜¯ç¬¬ä¸€é¡µï¼Œåˆ™å›åˆ°ä¸Šä¸€é¡µ
                        if not self.bookshelf.books and page > 0:
                            page -= 1
                        # è°ƒæ•´å½“å‰é€‰ä¸­è¡Œï¼Œç¡®ä¿ä¸è¶Šç•Œ
                        if current_selection >= len(current_page_books):
                            current_selection = max(0, len(current_page_books) - 1)
        
        # è¿”å›ä¹¦æ¶ä¸»ç•Œé¢
        self.show_bookshelf()

    def update_missing_book_path(self, book_id):
        """æ›´æ–°ä¸¢å¤±ä¹¦ç±çš„è·¯å¾„"""
        max_y, max_x = self.stdscr.getmaxyx()
        book = self.bookshelf.get_book_by_id(book_id)
        if not book:
            return
            
        new_path = input_box(self.stdscr, f"{get_text('books', self.lang)} '{book['title']}' {get_text('unfind_type_new', self.lang)}: ", maxlen=200)
        if new_path and os.path.exists(new_path):
            if self.bookshelf.update_book_path(book_id, new_path):
                msg = f"{get_text('update_path_success', self.lang)}"
                self.stdscr.addstr(max_y-2, 2, msg)
                self.stdscr.refresh()
                time.sleep(1)
            else:
                msg = f"{get_text('update_path_fail', self.lang)}"
                self.stdscr.addstr(max_y-2, 2, msg)
                self.stdscr.refresh()
                time.sleep(1)
        else:
            msg = f"{get_text('path_not_exists', self.lang)}"
            self.stdscr.addstr(max_y-2, 2, msg)
            self.stdscr.refresh()
            time.sleep(1)

    def show_batch_tag_edit(self, book_ids):
        """æ˜¾ç¤ºæ‰¹é‡æ ‡ç­¾ç¼–è¾‘ç•Œé¢ - æ”¹è¿›UI"""
        if not book_ids:
            return
            
        current_action = 0  # 0: æ·»åŠ æ ‡ç­¾, 1: ç§»é™¤æ ‡ç­¾
        tag_input = ""
        
        while True:
            self.stdscr.clear()
            max_y, max_x = self.stdscr.getmaxyx()
            
            # æ˜¾ç¤ºæ ‡é¢˜
            title = f"ğŸ·ï¸ æ‰¹é‡æ ‡ç­¾ç¼–è¾‘ ({len(book_ids)} æœ¬ä¹¦)"
            self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            self.stdscr.addstr(0, max_x // 2 - len(title) // 2, title)
            self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
            
            # æ˜¾ç¤ºåˆ†éš”çº¿
            sep_line = "â”€" * (max_x - 4)
            self.stdscr.attron(curses.color_pair(10))
            self.stdscr.addstr(1, 2, sep_line)
            self.stdscr.attroff(curses.color_pair(10))
            
            # æ˜¾ç¤ºæ“ä½œé€‰é¡¹
            actions = ["æ·»åŠ æ ‡ç­¾", "ç§»é™¤æ ‡ç­¾"]
            for idx, action in enumerate(actions):
                line = f"{'â†’' if idx == current_action else ' '} {action}"
                color = curses.color_pair(2) if idx == current_action else curses.color_pair(1)
                self.stdscr.attron(color)
                self.stdscr.addstr(3 + idx, 4, line)
                self.stdscr.attroff(color)
            
            # æ˜¾ç¤ºæ ‡ç­¾è¾“å…¥æ¡† - æ”¹è¿›UIä½¿å…¶æ›´æ˜æ˜¾
            self.stdscr.attron(curses.color_pair(3) | curses.A_BOLD)
            self.stdscr.addstr(6, 4, "è¯·è¾“å…¥æ ‡ç­¾åç§°:")
            self.stdscr.attroff(curses.color_pair(3) | curses.A_BOLD)
            
            # ç»˜åˆ¶è¾“å…¥æ¡†
            input_width = min(40, max_x - 10)
            self.stdscr.attron(curses.color_pair(2))
            self.stdscr.addstr(7, 4, "â•­" + "â”€" * input_width + "â•®")
            self.stdscr.addstr(8, 4, "â”‚" + " " * input_width + "â”‚")
            self.stdscr.addstr(9, 4, "â•°" + "â”€" * input_width + "â•¯")
            
            # æ˜¾ç¤ºè¾“å…¥å†…å®¹
            display_input = tag_input[:input_width]
            if len(tag_input) > input_width:
                display_input = "..." + tag_input[-input_width+3:]
                
            self.stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
            self.stdscr.addstr(8, 6, display_input)
            
            # æ˜¾ç¤ºå…‰æ ‡
            if time.time() % 1 < 0.5:  # é—ªçƒå…‰æ ‡
                cursor_pos = min(len(display_input), input_width - 2)
                try:
                    self.stdscr.addstr(8, 6 + cursor_pos, "_")
                except:
                    pass
                    
            self.stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
            
            # æ˜¾ç¤ºæ“ä½œæç¤º
            help_text = "[â†‘â†“] é€‰æ‹©æ“ä½œ [Enter] ç¡®è®¤ [q] è¿”å›"
            self.stdscr.attron(curses.color_pair(3) | curses.A_DIM)
            self.stdscr.addstr(11, 4, help_text[:max_x-8])
            self.stdscr.attroff(curses.color_pair(3) | curses.A_DIM)
            
            # æ˜¾ç¤ºåˆ†éš”çº¿
            self.stdscr.attron(curses.color_pair(10))
            self.stdscr.addstr(12, 2, sep_line)
            self.stdscr.attroff(curses.color_pair(10))
            
            self.stdscr.refresh()
            
            c = self.stdscr.getch()
            if c == ord('q'):
                break
            elif c == curses.KEY_UP:
                if current_action > 0:
                    current_action -= 1
            elif c == curses.KEY_DOWN:
                if current_action < len(actions) - 1:
                    current_action += 1
            elif c in (10, 13):  # å›è½¦é”®
                if tag_input:
                    action = "add" if current_action == 0 else "remove"
                    self.bookshelf.batch_update_tags(book_ids, action, tag_input)
                    # æ˜¾ç¤ºæ“ä½œç»“æœ
                    result_msg = f"å·²ä¸º {len(book_ids)} æœ¬ä¹¦{actions[current_action]} '{tag_input}'"
                    self.stdscr.addstr(14, 4, result_msg)
                    self.stdscr.refresh()
                    time.sleep(1)
                    break
            elif 32 <= c <= 126:  # å¯æ‰“å°å­—ç¬¦
                tag_input += chr(c)
            elif c == curses.KEY_BACKSPACE or c == 127:  # é€€æ ¼é”®
                if tag_input:
                    tag_input = tag_input[:-1]

    def run(self):
        if self.current_book:
            while self.running:
                if self.boss_mode:
                    self.display_terminal()
                    c = self.stdscr.getch()
                    self.handle_terminal_input(c)
                else:
                    self.display()
                    self.handle_input()
                    self.save_progress()
                    self.stats.record_reading(self.current_book["id"], int(time.time() - self.start_time))
                    self.check_remind()
                    self.start_time = time.time()
                    if self.auto_page:
                        time.sleep(self.settings["auto_page_interval"])
                        self.next_page()
        else:
            self.show_bookshelf()
            while self.running:
                if self.boss_mode:
                    self.display_terminal()
                    c = self.stdscr.getch()
                    self.handle_terminal_input(c)
                else:
                    self.display()
                    self.handle_input()
                    self.save_progress()
                    self.stats.record_reading(self.current_book["id"], int(time.time() - self.start_time))
                    self.check_remind()
                    self.start_time = time.time()
                    if self.auto_page:
                        time.sleep(self.settings["auto_page_interval"])
                        self.next_page()
                        
        # ç¡®ä¿åœ¨é€€å‡ºå‰åœæ­¢æœ—è¯»
        self.stop_reading()

./settings.py
----------------------------------------
import os
import json

def get_config_path():
    home = os.environ.get("HOME")
    config_dir = os.path.join(home, ".config", "preader")
    os.makedirs(config_dir, exist_ok=True)
    return os.path.join(config_dir, "settings.json")

DEFAULT_SETTINGS = {
    "width": 200,
    "height": 50,
    "theme": "dark",
    "lang": "zh",
    "font_color": "white",
    "bg_color": "black",
    "border_style": "round",
    "border_color": "blue",
    "margin": 1,
    "padding": 2,
    "line_spacing": 1,
    "status_bar": True,
    "auto_page_interval": 5,
    "remind_interval": 0
}

class Settings:
    def __init__(self):
        self.path = get_config_path()
        self.settings = DEFAULT_SETTINGS.copy()
        self.load()

    def load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                self.settings.update(data)
            except Exception:
                pass

    def save(self):
        with open(self.path, "w", encoding="utf-8") as f:
            json.dump(self.settings, f, ensure_ascii=False, indent=2)

    def __getitem__(self, key):
        return self.settings.get(key, DEFAULT_SETTINGS.get(key))

    def __setitem__(self, key, value):
        self.settings[key] = value

./stats.py
----------------------------------------
from db import DBManager
import datetime

class StatsManager:
    def __init__(self):
        self.db = DBManager()

    def record_reading(self, book_id, seconds):
        date = datetime.date.today().isoformat()
        self.db.record_stat(book_id, date, seconds)

    def get_book_stats(self, book_id):
        records = self.db.get_stats(book_id)
        total_time = sum(v for _, v in records)
        days = len(records)
        return {
            "total_time": total_time,
            "days": days,
            "records": records
        }

    def get_all_books_stats(self):
        # Returns stats for all books as {book_id: {total_time, days, records}}
        all_books = self.db.get_books()
        result = {}
        for book in all_books:
            book_id = book[0]
            result[book_id] = self.get_book_stats(book_id)
        return result

./ui_theme.py
----------------------------------------
import curses

COLOR_MAP = {
    "black": 0,
    "red": 1,
    "green": 2,
    "yellow": 3,
    "blue": 4,
    "magenta": 5,
    "cyan": 6,
    "white": 7,
}

THEMES = {
    "dark": {
        "font": "white",
        "bg": "black",
        "highlight": "cyan",
        "progress": "green",
        "border": "blue"
    },
    "light": {
        "font": "black",
        "bg": "white",
        "highlight": "red",
        "progress": "magenta",
        "border": "yellow"
    },
    "eye": {
        "font": "green",
        "bg": "black",
        "highlight": "yellow",
        "progress": "green",
        "border": "green"
    }
}

BORDER_CHARS = {
    "single": ('|', '-', '+'),
    "double": ('â•‘', 'â•', 'â•¬'),
    "bold": ('â”ƒ', 'â”', 'â•‹'),
    "round": ('â”‚', 'â”€', 'â—‹'),
    "none": (' ', ' ', ' '),
}

def color_pair_idx(idx, fg, bg):
    fg_c = COLOR_MAP.get(fg, curses.COLOR_WHITE)
    bg_c = COLOR_MAP.get(bg, curses.COLOR_BLACK)
    curses.init_pair(idx, fg_c, bg_c)
    return curses.color_pair(idx)

def init_colors(theme="dark", settings=None):
    curses.start_color()
    t = THEMES[theme]
    font_color = settings["font_color"] if settings else t["font"]
    bg_color = settings["bg_color"] if settings else t["bg"]
    highlight_color = t["highlight"]
    progress_color = t["progress"]
    border_color = settings["border_color"] if settings else t["border"]

    color_pair_idx(1, font_color, bg_color)
    color_pair_idx(2, highlight_color, bg_color)
    color_pair_idx(3, progress_color, bg_color)
    color_pair_idx(4, border_color, bg_color)
    color_pair_idx(10, border_color, bg_color)

./utils.py
----------------------------------------
import chardet
import cjkwrap
from lang import get_text

def detect_encoding(file_path):
    with open(file_path, "rb") as f:
        raw = f.read(10000)
    res = chardet.detect(raw)
    encoding = res["encoding"] if res and res["encoding"] else "utf-8"
    return encoding

def stream_file_as_text(file_path):
    encoding = detect_encoding(file_path)
    with open(file_path, "r", encoding=encoding, errors="ignore") as f:
        return f.read()

def build_pages_from_text(text, width, height, line_spacing, progress_callback=None, lang="zh"):
    """
    å°†æ–‡æœ¬å†…å®¹åˆ†é¡µï¼Œè€ƒè™‘è¡Œé—´è·å’Œé¡µé¢é«˜åº¦
    """

    # æ£€æŸ¥æ–‡æœ¬æ˜¯å¦ä¸ºç©º
    if not text or not text.strip():
        return [[f"{get_text('empty_directory_or_file', lang)}"]]

    display_lines = []
    # åˆå¹¶æ‰€æœ‰æ–‡æœ¬ä¸ºæ˜¾ç¤ºè¡Œåˆ—è¡¨
    lines = text.replace('\r\n', '\n').replace('\r', '\n').split('\n')
    
    total_lines = len(lines)
    for i, rawline in enumerate(lines):
        # cjkwrap.wrap è¿”å›æ¯è¡Œä¸è¶…è¿‡ width çš„å­—ç¬¦ä¸²åˆ—è¡¨
        for sub_line in cjkwrap.wrap(rawline, width):
            display_lines.append(sub_line)
            for _ in range(line_spacing - 1):
                display_lines.append("")
        
        # æ¯100è¡ŒæŠ¥å‘Šä¸€æ¬¡è¿›åº¦
        if progress_callback and i % 100 == 0:
            progress_callback(f"{get_text('action_document_line', lang)}: {i}/{total_lines}")
            
    # é€é¡µåˆ‡åˆ†ï¼Œä¸ä¸¢ä»»ä½•å†…å®¹
    pages = []
    idx = 0
    total_display_lines = len(display_lines)
    
    while idx < total_display_lines:
        page = display_lines[idx:idx+height]
        pages.append(page)
        idx += height
        
        # æ¯10é¡µæŠ¥å‘Šä¸€æ¬¡è¿›åº¦
        if progress_callback and idx % (height * 10) == 0:
            progress_callback(f"{get_text('action_pages', lang)}: {idx}/{total_display_lines}")
            
    return pages

def build_pages_from_file(file_path, width, height, line_spacing, progress_callback=None, lang="zh"):
    """
    å®Œå…¨ä¸ä¸¢å¤±å†…å®¹çš„åˆ†é¡µç®—æ³•ï¼ˆé€æ˜¾ç¤ºè¡Œæµå¼åˆ†é¡µï¼Œæ”¯æŒä¸­è‹±æ–‡æ··åˆå®½åº¦ï¼‰ã€‚
    width: æ¯è¡Œæ˜¾ç¤ºå®½åº¦
    height: æ¯é¡µæœ€å¤§è¡Œæ•°
    line_spacing: è¡Œé—´è·
    """
    if progress_callback:
        progress_callback(f"{get_text('reading_from_file', lang)}")
    text = stream_file_as_text(file_path)
    
    # æ£€æŸ¥æ–‡æœ¬æ˜¯å¦ä¸ºç©º
    if not text or not text.strip():
        return [[f"{get_text('empty_directory_or_file', lang)}"]]

    if progress_callback:
        progress_callback(f"{get_text('action_document_file', lang)}")
    pages = build_pages_from_text(text, width, height, line_spacing, progress_callback)
    
    return pages

ä»¥ä¸Šä»£ç æ˜¯ä¸€æ¬¾macç³»ç»Ÿä¸‹çš„ç»ˆç«¯å°è¯´é˜…è¯»å™¨, åœ¨æ‰¹é‡è®¾ç½®ä¹¦ç­¾çš„æ—¶å€™,åªæœ‰1åˆ°2ä¸ªä¼šè¢«è®¾ç½®ä¸Šä¹¦ç­¾,å…¶ä»–é€‰ä¸­éƒ½ä¸ä¼šè¢«è®¾ç½®,è¯·å¸®æˆ‘å¤„ç†è¿™ä¸ªé—®é¢˜,å¹¶ç»™å‡ºæ¯ä¸ªå‡½æ•°æ•´åˆåçš„å®Œæ•´çš„å‡½æ•°