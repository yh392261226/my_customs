#!/usr/bin/env bash

##############################################
# 文件操作增强工具 - Actioner
# 功能：根据文件类型提供上下文相关操作菜单
# 特性：
# 1. 支持 30+ 种文件类型识别
# 2. 智能上下文菜单显示
# 3. 安全的操作确认机制
# 4. 终端状态保护机制
# 依赖：
# - fzf: 菜单选择工具
# - bat: 代码高亮查看
# - termpdf: PDF预览
# - viu: 图片预览
##############################################

# 初始化操作环境
init_terminal() {
    # 保存原始终端设置
    original_stty=$(stty -g)
    # 设置安全模式
    stty sane -echoctl
}

# 恢复终端设置
restore_terminal() {
    stty "$original_stty"
}

# 安全读取输入
safe_read() {
    local prompt=$1
    if command -v gum >/dev/null; then
        input=$(gum input --placeholder "$prompt")
    else
        read -rep "$prompt" input </dev/tty
    fi
    echo "$input"
}

# 安全读取选择
safe_choose() {
    local prompt=$1
    if command -v gum >/dev/null; then
        echo "$prompt"
        choose=$(gum choose "yes" "no")
    else
        read -rep "$prompt" choose </dev/tty
    fi
    echo "$choose"
}

#----------------------- 核心操作函数 -----------------------#

# 删除操作
actioner_delete() {
    local target="$1"
    # echo -n "确认删除 '$target' 吗？(y/N) "
    local confirm=$(safe_choose "确认删除 '$target' 吗？")
    
    if [[ $confirm =~ yes ]]; then
        rm -rfv "$target"
    else
        echo "取消删除操作"
    fi
}

# 复制操作
actioner_copy() {
    local source="$1"
    local dest
    dest=$(safe_read "输入目标路径 (从 $source 复制到): ")
    
    if [[ -z "$dest" ]]; then
        echo "错误：未指定目标路径"
        return 1
    fi
    
    if [[ -e "$dest" ]]; then
        echo -n "目标 '$dest' 已存在，覆盖吗？(y/N) "
        local overwrite=$(safe_read "")
        [[ ! $overwrite =~ ^[Yy]$ ]] && return
    fi
    
    cp -Rfv "$source" "$dest"
}

# 移动操作
actioner_move() {
    local source="$1"
    local dest
    dest=$(safe_read "输入目标路径 (移动 $source 到): ")
    
    if [[ -e "$dest" ]]; then
        echo -n "目标 '$dest' 已存在，覆盖吗？(y/N) "
        local overwrite=$(safe_read "")
        [[ ! $overwrite =~ ^[Yy]$ ]] && return
    fi
    
    mv -iv "$source" "$dest"
}

# 重命名操作
actioner_rename() {
    local source="$1"
    local newname
    newname=$(safe_read "输入新名称 (重命名 $source 为): ")
    
    if [[ -e "$newname" ]]; then
        echo "错误：'$newname' 已存在"
        return 1
    fi
    
    mv -v "$source" "$newname"
}

# 压缩操作
actioner_archive() {
    local source="$1"
    local archive_path
    archive_path=$(safe_read "输入压缩包路径 (保存为): ")
    
    # 自动添加扩展名
    if [[ ! "$archive_path" =~ \..+$ ]]; then
        archive_path="${archive_path}.tar.gz"
        echo "自动添加扩展名: $archive_path"
    fi
    
    case "$archive_path" in
        *.tar.bz2)   tar cvjf "$archive_path" "$source" ;;
        *.tar.gz)    tar cvzf "$archive_path" "$source" ;;
        *.tar.xz)    tar cvJf "$archive_path" "$source" ;;
        *.tar)       tar cvf "$archive_path" "$source"  ;;
        *.zip)       zip -r "$archive_path" "$source"   ;;
        *.7z)        7z a "$archive_path" "$source"     ;;
        *)           echo "不支持的压缩格式"; return 1     ;;
    esac
    
    echo "压缩完成 → $archive_path"
}

# 解压操作
actioner_extract() {
    local archive="$1"
    local extract_to
    extract_to=$(safe_read "输入解压路径 (默认为当前目录): ")
    
    # 自动生成解压目录名
    if [[ -z "$extract_to" ]]; then
        extract_to="${archive%.*}"
        mkdir -p "$extract_to"
    fi
    
    # 支持格式列表
    case "$archive" in
        *.tar.bz2|*.tbz2)  tar xvjf "$archive" -C "$extract_to" ;;
        *.tar.gz|*.tgz)    tar xvzf "$archive" -C "$extract_to" ;;
        *.tar.xz)          tar xvJf "$archive" -C "$extract_to" ;;
        *.zip)             unzip "$archive" -d "$extract_to"    ;;
        *.7z)              7z x "$archive" -o"$extract_to"      ;;
        *.rar)             unrar x "$archive" "$extract_to"     ;;
        *)                 echo "不支持的压缩格式"; return 1       ;;
    esac
    
    echo "解压完成 → $extract_to"
}

# 查看压缩包内容
actioner_archive_peek() {
    local archive="$1"
    case "$archive" in
        *.tar.*)    tar tvf "$archive"             ;;
        *.zip)      unzip -l "$archive"            ;;
        *.7z)       7z l "$archive"                ;;
        *.rar)      unrar l "$archive"             ;;
        *)          echo "不支持的压缩格式"; return 1 ;;
    esac
}

# 添加书签
actioner_add_bookmark() {
    local name="$1"
    local path="$2"
    local desc="$3"

    # 检查书签名称是否有效
    if [[ -z "$name" ]]; then
        echo "错误：书签名称不能为空"
        return 1
    fi
    if [ ! -f ${TMP_FZF_BOOKMARKS_PATH}/${name} ]; then
        # 添加新书签
        touch ${TMP_FZF_BOOKMARKS_PATH}/${name}
        echo "${path}" > "${TMP_FZF_BOOKMARKS_PATH}/${name}"
        echo "#Desc:${desc}" >> "${TMP_FZF_BOOKMARKS_PATH}/${name}"
    else
        echo "${path}" > "${TMP_FZF_BOOKMARKS_PATH}/${name}"
        echo "#Desc:${desc}" >> "${TMP_FZF_BOOKMARKS_PATH}/${name}"
    fi
}

# 查看权限
actioner_get_private() {
    local path="$1"
    echo "$path"
    echo $(stat -f "%Sp -> %OLp" "$path")
    echo ""
    echo ""
    echo ""
}

# 设置权限
actioner_set_private() {
    local path="$1"
    local private_value=$(safe_read "输入权限 (如 755): ")
    if [[ -z "$private_value" ]]; then
        echo "错误：未指定权限"
        return 1
    fi
    chmod $private_value "$path"
    echo "Done ..."
}

# 创建
actioner_create() {
    local path=$1
    local name
    local type
    local prompt="创建类型（dir/file）"
    local prompt1="输入文件名"
    if command -v gum >/dev/null; then
        echo "$prompt"
        type=$(gum choose "目录" "文件")
        name=$(safe_read "$prompt1")
    else
        read -rep "$prompt" type </dev/tty
        read -rep "$prompt1" name </dev/tty
    fi
    if [[ $type == "dir" ]] || [[ $type == "目录" ]]; then
        mkdir $path/$name
    elif [[ $type == "file" ]] || [[ $type == "文件" ]]; then
        touch $path/$name
    fi
}

# 查看原身
actioner_view_origin() {
    local file="$1"
    echo "source: $file" | lolcat -f -F 0.05
    local target=$(readlink "$file")
    echo "target: $target" | lolcat -f -F 0.05
    file $target  | lolcat -f -F 0.05
    return
}

#----------------------- 文件类型处理 -----------------------#

# 识别文件类型
detect_filetype() {
    local path="$1"
    local islink=0
    local result

    # 验证是否是软链接
    if [[ -L $path ]]; then
        islink=1
        path=$(readlink $path)
    fi

    # 验证文件夹
    if [[ -d "$path" ]] && [ "1" = "$islink" ]; then
        echo "symlink_directory"
        return
    elif [[ -d "$path" ]]; then
        echo "directory"
        return
    fi
    
    # 其他文件类型
    local mime_type=$(file --mime-type -b "$path" 2>/dev/null)
    
    case "$mime_type" in
        text/*|*/xml|application/json)    result="text"    ;;
        image/*)                          result="image"   ;;
        video/*)                          result="video"   ;;
        audio/*)                          result="audio"   ;;
        application/pdf)                  result="pdf"     ;;
        application/epub+zip)             result="ebook"   ;;
        application/vnd.openxmlformats*)  result="office"  ;;
        application/zip|application/x-*)  result="archive" ;;
        application/x-shellscript)        result="script"  ;;
        application/x-executable)         result="binary"  ;;
        *)                                result="other"   ;;
    esac

    if [ "1" = "$islink" ]; then
        result="symlink_$result"
    fi
    echo $result
}

# 生成上下文菜单
generate_menu() {
    local filetype="$1"
    local text=''
    [[ $filetype =~ symlink_ ]] && text=' 查看原身'
    case "$filetype" in
        "directory"|"symlink_directory")
            echo "进入目录 创建 删除 复制 移动 重命名 压缩 打开位置 收藏 查看权限 设置权限${text} 取消" ;;
        "text"|"symlink_text")
            echo "编辑(Nvim) 编辑(Code) 查看(Bat) 查看(Cat) 查看(终端) 创建 复制 移动 删除 压缩 收藏 查看权限 设置权限${text} 当小说读 取消" ;;
        "pdf"|"symlink_pdf")
            echo "文本预览 打开文件 复制 移动 删除 压缩 收藏 查看权限 设置权限${text} 取消" ;;
        "office"|"symlink_office")
            echo "打开文件 复制 移动 删除 压缩 收藏 查看权限 设置权限${text} 取消" ;;
        "archive"|"symlink_archive")
            echo "解压 查看内容 复制 移动 删除 收藏 查看权限 设置权限${text} 取消" ;;
        "image"|"symlink_image")
            echo "预览图片 打开文件 收藏图片 复制 移动 删除 压缩 收藏 查看权限 设置权限${text} 取消" ;;
        "video"|"audio"|"symlink_video"|"symlink_audio")
            echo "终端播放 打开文件 复制 移动 删除 收藏 查看权限 设置权限${text} 取消" ;;
        "script"|"symlink_script")
            echo "执行脚本 创建 编辑 查看 复制 移动 删除 收藏 查看权限 设置权限${text} 取消" ;;
        *)
            echo "打开文件 创建 复制 移动 删除 压缩 收藏 查看权限 设置权限 取消" ;;
    esac
}

#----------------------- 主逻辑 -----------------------#

actioner() {
    [[ -z "$1" ]] && return
    
    init_terminal
    trap restore_terminal EXIT
    
    # 解析文件路径和行号
    local raw_path="$1"
    local filepath="${raw_path%%:*}"
    local line_num=1
    
    if [[ "$raw_path" =~ :[0-9]+: ]]; then
        line_num=$(echo "$raw_path" | cut -d: -f2)
    fi
    
    # 验证文件存在
    if [[ ! -e "$filepath" ]]; then
        echo "错误：文件不存在 '$filepath'"
        return 1
    fi
    
    # 识别文件类型
    local filetype=$(detect_filetype "$filepath")
    
    # 生成上下文菜单
    local menu_options=$(generate_menu "$filetype")
    
    # 显示交互菜单 , 如果有第二个参数则 action 采用第二个参数的值，否则由用户选择 action
    local action
    if [ "" != "$2" ]; then
        action="$2"
    else
        action=$(echo "$menu_options" | tr ' ' '\n' | \
        fzf --height 20% --reverse --header " 操作菜单 ($filetype) ")
    fi
    # 执行操作
    case "$action" in
        删除*)           actioner_delete "$filepath"       ;;
        复制*)           actioner_copy "$filepath"         ;;
        移动*)           actioner_move "$filepath"         ;;
        重命名*)         actioner_rename "$filepath"        ;;
        压缩*)           actioner_archive "$filepath"      ;;
        解压*)           actioner_extract "$filepath"      ;;
        查看内容*)        actioner_archive_peek "$filepath" ;;
        查看权限*)        actioner_get_private "$filepath" ;;
        进入目录*)        cd "$filepath" && exec $SHELL     ;;
        编辑*)        
            case $action in
                *Nvim*) nvim +$line_num "$filepath"        ;;
                *Code*) code --goto "$filepath:$line_num"  ;;
            esac ;;
        查看原身*)        actioner_view_origin "$filepath"   ;;
        查看*)
            case $action in
                *Bat*)  bat --style=full "$filepath"       ;;
                *Cat*)  cat "$filepath"                    ;;
                *终端*)
                    if [ "$(file -b --mime-encoding $filepath)" != "utf-8" ]; then
                        piconv -f GB2312 -t UTF-8 "$filepath" | bat --theme=gruvbox-dark --color=always --style=full
                    else
                        bat --theme=gruvbox-dark --color=always --style=full "$filepath"
                    fi
                 ;;
            esac ;;
        执行脚本*)    
            [[ $(safe_choose "确认执行脚本？") =~ yes ]] && bash "$filepath" ;;
        打开文件*)        open "$filepath"                        ;;
        打开位置*)        open -R "$filepath"                     ;;
        终端播放*)        mpv --vo=tct "$filepath"                ;;
        预览图片*)        viu "$filepath" || open "$filepath"     ;;
        收藏图片*)
            if [ -f "${PWD}/$(basename $filepath)" ]; then
                $MYRUNTIME/customs/bin/favo a "${PWD}/$(basename $filepath)"
            else
                $MYRUNTIME/customs/bin/favo a "$filepath"
            fi
            ;;
        收藏*)
            local name
            local desc
            if command -v gum >> /dev/null; then
                name=$(gum input --placeholder "输入书签名称")
            else
                read -r -p "输入书签名: " name
            fi
            [ -z "$name" ] && return
            if command -v gum >> /dev/null; then
                desc=$(gum write --placeholder "输入描述")
            else
                read -r -p "输入描述：" desc
            fi
            actioner_add_bookmark "$name" "$filepath" "$desc"
        ;;
        设置权限*)        actioner_set_private "$filepath" ;;
        文本预览*)        $MYRUNTIME/customs/bin/termpdf -sixel "$filepath" ;;
        创建*)           actioner_create "$filepath" ;;
        当小说读*)        $MYRUNTIME/customs/bin/greader "$filepath" ;;
    esac
    
    restore_terminal
}

# 执行入口
actioner "$@"